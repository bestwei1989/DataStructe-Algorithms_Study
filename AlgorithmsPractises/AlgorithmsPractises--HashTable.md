### AlgorithmsPractises--HashTable

------

记录算法练习中的练习题以及实现的代码，练习题主要是来自[LeetCode](https://leetcode.com/problemset/algorithms/)，主要还是按照级别，由简单到难的顺序练习，并且主要是有关哈希表的算法题。

##### 1 [Single Number](https://leetcode.com/problems/single-number/)

题目描述如下：

> Given an array of integers, every element appears *twice* except for one. Find that single one.

给定一个数组，这个数组中除了一个数字只出现一次外，其余数字都出现两次，要求寻找只出现一次的数组元素。解法如下：

```c++
class Solution {
public:
    int singleNumber(vector<int>& nums) {
        if(nums.size() <= 0)
            return 0;
        int lens = nums.size();
        int res = nums[0];
        for(int i=1; i<lens; i++){
            res ^= nums[i];
        }
        return res;
    }
};
```

上述解法使用了**异或**的方法，两个相同的数字异或会得到0，因此对数组元素依次进行异或，最终得到的结果就是只出现一次的数组元素，这个方法不需要额外的辅助空间，时间复杂度也只需要$O(n)$。

##### 2 [Single Number II](https://leetcode.com/problems/single-number-ii/)

题目描述如下：

> Given an array of integers, every element appears *three* times except for one, which appears exactly once. Find that single one.

相比第一题，这题从出现两次变成三次，不能简单使用异或了。解法如下：

```c++
class Solution {
public:
    int singleNumber(vector<int>& nums) {
        if(nums.size() <= 0)
            return 0;
        int lens = nums.size();
        map<int, int> res;
        for(int i=0; i<lens; i++){
            if(res.find(nums[i]) != res.end()){
                res[nums[i]]++;
            }else{
                res[nums[i]] = 1;
            }
        }
        int r=0;
        for(int i=0; i<lens; i++){
            if(res[nums[i]] == 1){
                r = nums[i];
            }
        }
        return r;
    }
};
```

这是使用了哈希表，但是耗费时间比较长。

另一种解法如下：

```c++
class Solution {
public:
    int singleNumber(vector<int>& nums) {
        vector<int> t(32);////Made a array contain 32 elements.
    	int sz = nums.size();
    	int i, j, n;
    	for (i = 0; i < sz; ++i)
    	{
    		n = nums[i];
    		for (j = 31; j >= 0; --j)
    		{
    			t[j] += n & 1;//Find the last digit.
    			n >>= 1;
    			if (!n)
    				break;
    	    }
        }
    	int res = 0;
    	for (j = 31; j >= 0; --j)
    	{
    		n = t[j] % 3;//"3" represents k times. 
    		if (n)
    			res += 1 << (31 - j);
    	}
    	return res;
    }
};
```

这是首先定义一个长度为32的`vector`，它负责存放每个数组元素对应每位的相加和，然后在第二次循环中，每位相加和都会对3进行求余，因为数组中只有一个数字只出现1次，其他都是3次，在不计算这个单独的数字外，每个位的相加和应该都是3的倍数，一旦不是3的倍数，说明该位就是这个单独数字中不为0的位，然后只要将这些位叠加就得到目标数字了。

##### 3 [Find the Difference](https://leetcode.com/problems/find-the-difference/)

题目描述如下：

> Given two strings **s** and **t** which consist of only lowercase letters.
>
> String **t** is generated by random shuffling string **s** and then add one more letter at a random position.
>
> Find the letter that was added in **t**.
>
> **Example:**
>
> ```
> Input:
> s = "abcd"
> t = "abcde"
>
> Output:
> e
>
> Explanation:
> 'e' is the letter that was added.
> ```

给定两个字符串，寻找第二个字符串中增加的字符。解法如下：

```c++
class Solution {
public:
    char findTheDifference(string s, string t) {
        char r=0;
        for(char c:s) 
            r ^=c;
        for(char c:t) 
            r ^=c;
        return r;
    }
};
```

这是使用了异或的思路。因为字符也是可以转换成整数来进行异或运算的。

