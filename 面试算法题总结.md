### 面试算法题总结

------

### 排序算法

#### 1. 小范围排序

题目描述如下：

> 已知一个几乎有序的数组，几乎有序是指，如果把数组排好顺序的话，每个元素移动的距离可以不超过k，并且k相对于数组来说比较小。请选择一个合适的排序算法针对这个数据进行排序。
>
> 给定一个int数组**A**，同时给定A的大小**n**和题意中的**k**，请返回排序后的数组。
>
> 测试样例：
>
> > [2,1,4,3,6,5,8,7,10,9],10,2
>
> > 返回：[1,2,3,4,5,6,7,8,9,10]

解法如下：

```c++
class ScaleSort {
public:
    vector<int> sortElement(vector<int> A, int n, int k) {
        // write code here
        // 建立一个最小堆
        vector<int>  myheap(A.begin(), A.begin() + k);
        buildHeap(myheap, k);
        // 每次弹出堆顶，并加入下一个元素，即i+k
        for (int i = 0; i != n - k; i++){
            A[i] = myheap[0];
            myheap[0] = A[i + k];
            heapSort(myheap, 0, k);
        }
        // 对于剩下的n-k 到 n-1位置的元素的处理
        for (int i = 0; i != k; i++){
            // 起始位置是从 n-k 开始的
            A[i + n - k] = myheap[0];
            // 堆内将堆顶和堆后面的元素依次交换
            myheap[0] = myheap[k - 1 - i];
            heapSort(myheap, 0, k - i);
        }
        return A;
        
    }
    // 建堆
    void buildHeap(vector<int>& a, int k){
        for(int i=k/2 -1; i>=0; --i)
            heapSort(a, i, k);
    }
    void heapSort(vector<int>& A, int i, int n){
        int left = i * 2 + 1;
        while (left < n){
            // 对比左右子树，选择更小的数值
            if (left + 1 < n && A[left] > A[left + 1])
                left++;
            // 再与父结点进行比较
            if (A[i] < A[left])
                return;
            else{
                int tmp = A[left];
                A[left] = A[i];
                A[i] = tmp;
                // 此时就继续往下比较，用left作为父结点，进行比较
                i = left;
                left = i * 2 + 1;
            }
        }
    }  
};
```

上述解法主要使用了堆排序，先建立一个长为`k`的最小堆，每次将堆顶按顺序放回到原数组中，然后要注意`n-k`位置后的元素个数会不足k个。并且堆排序要使用非递归形式，递归形式的空间复杂度是$O(logN)$。

#### 2. 重复值判断

题目描述如下：

> 请设计一个高效算法，判断数组中是否有重复值。必须保证额外空间复杂度为O(1)。
>
> 给定一个int数组**A**及它的大小**n**，请返回它是否有重复值。
>
> 测试样例：
>
> > [1,2,3,4,5,5,6],7
>
> > 返回：true

解法如下：

```c++
class Checker {
public:
    bool checkDuplicate(vector<int> a, int n) {
        // write code here
        // 建立一个最小堆
        buildHeap(a, n);
        // 排序
        for(int i=0; i<n; ++i){
            swap(a[n-i-1], a[0]);
            hSort(a, 0, n-i-1);
        }
        // 判断是否存在重复数值
        for(int i=1; i < n; ++i){
            if(a[i-1] == a[i])
                return true;
        } 
        return false;
    }
    void buildHeap(vector<int>& a, int n){
        for(int i= n/2-1; i >= 0; --i)
            hSort(a, i, n);
    }
    void hSort(vector<int>& A, int i, int n){
        int left = i * 2 + 1;
        while (left < n){
            // 对比左右子树，选择更小的数值
            if (left + 1 < n && A[left] > A[left + 1])
                left++;
            // 再与父结点进行比较
            if (A[i] < A[left])
                return;
            else{
                int tmp = A[left];
                A[left] = A[i];
                A[i] = tmp;
                // 此时就继续往下比较，用left作为父结点，进行比较
                i = left;
                left = i * 2 + 1;
            }
        }
    }
};
```

另一种解法，不满足空间复杂度的是如下：

```c++
class Checker {
public:
    bool checkDuplicate(vector<int> a, int n) {
        // write code here
        int min = a[0], max=a[0];
        // 查找数组中的最大值和最小值
        for(int i=1; i<n; ++i){
            min = (min < a[i])? min:a[i];
            max = (max > a[i])? max:a[i];
        }
        // 建立一个新的数组
        vector<int> tmp(max-min+1);
        // 统计每个索引值的数量，如果大于1，说明有重复值
        for(int i=0; i<n; ++i){
            if(++tmp[a[i]-min]>1)
                return true;
        }
        return false;
    }
};
```

这是一种新建一个数组，用于统计数组中每个数出现次数。

#### 3.  有序数组合并

题目如下：

> 有两个从小到大排序以后的数组A和B，其中A的末端有足够的缓冲空容纳B。请编写一个方法，将B合并入A并排序。
>
> 给定两个有序int数组**A**和**B**，A中的缓冲空用0填充，同时给定A和B的真实大小int **n**和int **m**，请返回合并后的数组。

解法如下：

```c++
class Merge {
public:
    int* mergeAB(int* A, int* B, int n, int m) {
        // write code here
        // 分别定义指向A和B数组尾元素位置的变量
        int pa = n-1, pb = m-1;
        // 定义指向A末尾刚好是两个数组大小的位置
        int p = n+m-1;
        while(pa>=0 && pb >= 0){
            // 通过比较，将较大数放在数组A末端
            A[p--] = (A[pa] >= B[pb])? A[pa--]:B[pb--];
        }
        // 如果数组B还有未进行比较的，直接复制到数组A前面
        while(pb >= 0)
            A[p--] = B[pb--];
        return A;
    }
};
```

这里采用从后往前进行比较来合并数组，并且注意如果数组A还有未进行比较的，可以直接跳过，而如果是数组B，则需要将其复制到数组A前面的相应位置。

#### 4. 三色排序

题目描述如下：

> 有一个只由0，1，2三种元素构成的整数数组，请使用交换、原地排序而不是使用计数进行排序。
>
> 给定一个只含0，1，2的整数数组**A**及它的大小，请返回排序后的数组。保证数组大小小于等于500。
>
> 测试样例：
>
> > [0,1,1,0,2,2],6
>
> > 返回：[0,0,1,1,2,2]

解法如下：

```c++
class ThreeColor {
public:
    vector<int> sortThreeColor(vector<int> A, int n) {
        // 数组左边设0区，右边设2区，把0放到数组0区，2放到数组2区，当遍历到2区时结束
        int start = 0, end = n-1;
        for(int i=0; i<n; ++i){
            if(i > end)
                break;
            if(A[i] == 0 && start < i)
                //交换后，下次判断还要为当前位置
                swap(A[i--], A[start++]);
            else if(A[i] == 2 && i < end)
                swap(A[i--], A[end--]);
        }
        return A;
    }
};
```

这是在左边设置0区，右边设置2区，即分别将0和2放到这两个区域，同时注意交换后还要判断交换过来的数值，以及这两个区的索引和当前进行循环的索引`i`大小的判断。

#### 5.  有序矩阵查找

题目如下：

> 现在有一个行和列都排好序的矩阵，请设计一个高效算法，快速查找矩阵中是否含有值x。
>
> 给定一个int矩阵**mat**，同时给定矩阵大小**n**x**m**及待查找的数**x**，请返回一个bool值，代表矩阵中是否存在x。所有矩阵中数字及**x**均为int范围内整数。保证**n**和**m**均小于等于1000。
>
> 测试样例：
>
> > [[1,2,3],[4,5,6],[7,8,9]],3,3,10
>
> > 返回：false

解法如下：

```c++
class Finder {
public:
    bool findX(vector<vector<int> > mat, int n, int m, int x) {
        if(n <= 0 || m <= 0 || mat.size() <= 0)
            return false;
        if(mat[0].size() <= 0)
            return false;
        // 从矩阵右上角开始查找
        int r = 0, c = m-1;
        while(r < n && c >= 0){
            if(mat[r][c] == x)
                return true;
            else if(mat[r][c] > x)
                --c;
            else
                ++r;
        }
        return false;
    }
};
```

上述解法是从矩阵右上角开始进行查找的。

#### 6. 最短子数组

题目如下：

> 对于一个数组，请设计一个高效算法计算需要排序的最短子数组的长度。
>
> 给定一个int数组**A**和数组的大小**n**，请返回一个二元组，代表所求序列的长度。(原序列位置从0开始标号,若原序列有序，返回0)。保证A中元素均为正整数。
>
> 测试样例：
>
> > [1,4,6,5,9,10],6
>
> > 返回：2

解法如下：

```c++
class Subsequence {
public:
    int shortestSubsequence(vector<int> A, int n) {
        int max=A[0], min=A[n-1];
        int rt=0, lt=0;
        // 从左到右遍历保存最大的数值，并记录比最大数要小的位置
        for(int i=0; i<n; ++i){
            max = (A[i] > max)? A[i] : max;
            rt = (A[i] < max)? i:rt;
        }
        // 从右到左遍历数组，保存最小值，并记录比最小值大的位置
        for(int i=n-1; i>=0; --i){
            min = (A[i] < min)? A[i]:min;
            lt = (A[i] > min)? i : lt;
        }
        return (rt != lt ? (rt-lt+1):0);
    }
};
```

先从左到右查找最大数，并记录比最大数小的位置，然后从右到左查找最小数，记录比最小数大的位置，判断两个位置是否相等，如果是，返回0，否则，则相减并加1。

#### 7.  相邻两数最大差值

题目如下：

> 有一个整形数组A，请设计一个复杂度为O(n)的算法，算出排序后相邻两数的最大差值。
>
> 给定一个int数组**A**和**A**的大小**n**，请返回最大的差值。保证数组元素多于1个。
>
> 测试样例：
>
> > [1,2,5,4,6],5
>
> > 返回：2

解法如下：

```c++
class Gap {
public:
    int maxGap(vector<int> A, int n) {
        int maxNum = getMax(A,n);
        // 建立一个桶
        vector<int> bucket(maxNum+1,0);
        // 统计数组中不同数值的个数
        for(int i=0; i<n; ++i){
            ++bucket[A[i]];
        }
        // 计算空缺的桶的索引值的差值
        int res = 0;
        int tmp = 0;
        for(int j=1; j<=maxNum; ++j){
            if(bucket[j] > 0){
                // 更新当前最大差值
                res = (res > tmp)? res:tmp;
                tmp = 0;
            }else{
                ++tmp;
            }
        }
        // 如果res!=0,需要加1
        return (res !=0)?(res+1) : res;
    }
    int getMax(vector<int> A, int n){
        int max=A[0];
        for(int i=1; i<n; ++i)
            max = (max > A[i])? max:A[i];
        return max;
    }
};
```

这是利用桶排序的思路，先根据数组最大值`maxNum`创建一个长度是`maxNum+1`的桶，然后根据数组元素的数值作为索引，找到其在桶中的位置，让对应位置的桶计数加1，之后通过空缺的桶的连续个数来得到数组相邻两数的最大差值。

### 字符串

#### 1. 词语变形

题目如下：

> 对于两个字符串A和B，如果A和B中出现的字符种类相同且每种字符出现的次数相同，则A和B互为变形词，请设计一个高效算法，检查两给定串是否互为变形词。
>
> 给定两个字符串**A**和**B**及他们的长度，请返回一个bool值，代表他们是否互为变形词。
>
> 测试样例：
>
> > "abc", 3, "bca", 3
>
> > 返回：true

解法如下：

```c++
class Transform {
public:
    bool chkTransform(string A, int lena, string B, int lenb) {
        // 分别建立两个数组作为哈希表
        char da[256] = {0}, db[256] = {0};
        // 分别统计两个数组的字符种类和出现个数
        for(int i=0; i<lena; ++i)
            ++da[A[i]];
        for(int j=0; j<lenb; ++j)
            ++db[B[j]];
        for(int k=0; k<256; ++k){
            if(da[k] != db[k])
                return false;
        }
        return true;
    }
};
```

这个方法主要是使用哈希表来分别统计两个数组的字符种类和出现次数，然后一一比较即可。

### 位运算

#### 1. 交换练习

> 给定一个数组**num**，其中包含两个值，请不用任何额外变量交换这两个值，并将交换后的数组返回。
>
> 测试样例：
>
>
> > [1,2]
>
> > 返回：[2,1]

解法如下：

```c++
vector<int> getSwap(vector<int> num) {
        // 使用异或交换两个数
        num[0] ^= num[1];
        num[1] ^= num[0];
        num[0] ^= num[1];
        return num;
}
```

使用异或方法进行交换两个数。

#### 2. 比较练习

> 对于两个32位整数a和b，请设计一个算法返回a和b中较大的。但是不能用任何比较判断。若两数相同，返回任意一个。
>
> 给定两个整数**a**和**b**，请返回较大的数。
>
> 测试样例：
>
> > 1,2
>
> > 返回：2

解法如下：

```c++
int getMax(int a, int b) {
        // 获取两个数的差值
        int c = a - b;
        // 查看符号位，如果是负数，结果是1，正数是0
        int flag = (c>>31) & 1;
        // flag是负数，返回b，是正数，则返回a
        return b*flag + a*(flag ^ 1);
}
```

解法主要是判断两个整数差值的符号位。

#### 3. 寻找奇数出现

> 有一个整型数组A，其中只有一个数出现了奇数次，其他的数都出现了偶数次，请打印这个数。要求时间复杂度为O(N)，额外空间复杂度为O(1)。
>
> 给定整形数组**A**及它的大小**n**，请返回题目所求数字。
>
> 测试样例：
>
> > [1,2,3,2,1],5
>
> > 返回：3

解法如下：

```c++
int findOdd(vector<int> A, int n) {
        int res = A[0];
        // 对每个数都进行异或，最终结果就是只出现奇数次的数字
        for(int i=1; i<n; ++i)
            res ^= A[i];
        return res;
    }
```

使用异或运算，偶数次的元素会变成0，剩下的结果就是奇数次的数。

#### 4. 奇数出现2

> 给定一个整型数组arr，其中有两个数出现了奇数次，其他的数都出现了偶数次，找到这两个数。要求时间复杂度为O(N)，额外空间复杂度为O(1)。
>
> 给定一个整形数组**arr**及它的大小**n**，请返回一个数组，其中两个元素为两个出现了奇数次的元素,请将他们按从小到大排列。
>
> 测试样例：
>
> > [1,2,4,4,2,1,3,5],8
>
> > 返回：[3,5]

解法如下：

```c++
class OddAppearance {
public:
    vector<int> findOdds(vector<int> arr, int n) {
        int res = 0;
        for(int i=0; i<n; ++i)
            res ^= arr[i];
        unsigned int indexOf1 = findBitsOf1(res);
        vector<int> r(2,0);
        for(int j=0; j<n; ++j){
            // 根据indexOf1位上是否为1分成两组
            if(isBit1(arr[j],indexOf1))
                r[0] ^= arr[j];
            else
                r[1] ^= arr[j];
        }
        sort(r.begin(), r.end());
        return r;
    }
    
    // 寻找出现1的位数
    unsigned int findBitsOf1(int n){
        int count = 0;
        while((n & 1) == 0 && count < sizeof(int) * 8){
            ++count;
            n = n >> 1;
        }
        return count;
    }
    // 判断给定的位数上是否为1
    bool isBit1(int n, unsigned int index){
        n = n >> index;
        return (n & 1);
    }
};
```

这个方法也是使用了异或，对数组的所有元素都进行异或后，得到的结果由于有两个数是奇数次，所以不为0，因此先找出第一个为1的位，根据这个将数组分成两部分，分别进行异或就可以得到结果。

