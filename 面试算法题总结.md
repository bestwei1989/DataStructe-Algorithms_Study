## 面试算法题总结

------

### 排序算法

#### 1. 小范围排序

题目描述如下：

> 已知一个几乎有序的数组，几乎有序是指，如果把数组排好顺序的话，每个元素移动的距离可以不超过k，并且k相对于数组来说比较小。请选择一个合适的排序算法针对这个数据进行排序。
>
> 给定一个int数组**A**，同时给定A的大小**n**和题意中的**k**，请返回排序后的数组。
>
> 测试样例：
>
> > [2,1,4,3,6,5,8,7,10,9],10,2
>
> > 返回：[1,2,3,4,5,6,7,8,9,10]

解法如下：

```c++
class ScaleSort {
public:
    vector<int> sortElement(vector<int> A, int n, int k) {
        // write code here
        // 建立一个最小堆
        vector<int>  myheap(A.begin(), A.begin() + k);
        buildHeap(myheap, k);
        // 每次弹出堆顶，并加入下一个元素，即i+k
        for (int i = 0; i != n - k; i++){
            A[i] = myheap[0];
            myheap[0] = A[i + k];
            heapSort(myheap, 0, k);
        }
        // 对于剩下的n-k 到 n-1位置的元素的处理
        for (int i = 0; i != k; i++){
            // 起始位置是从 n-k 开始的
            A[i + n - k] = myheap[0];
            // 堆内将堆顶和堆后面的元素依次交换
            myheap[0] = myheap[k - 1 - i];
            heapSort(myheap, 0, k - i);
        }
        return A;
        
    }
    // 建堆
    void buildHeap(vector<int>& a, int k){
        for(int i=k/2 -1; i>=0; --i)
            heapSort(a, i, k);
    }
    void heapSort(vector<int>& A, int i, int n){
        int left = i * 2 + 1;
        while (left < n){
            // 对比左右子树，选择更小的数值
            if (left + 1 < n && A[left] > A[left + 1])
                left++;
            // 再与父结点进行比较
            if (A[i] < A[left])
                return;
            else{
                int tmp = A[left];
                A[left] = A[i];
                A[i] = tmp;
                // 此时就继续往下比较，用left作为父结点，进行比较
                i = left;
                left = i * 2 + 1;
            }
        }
    }  
};
```

上述解法主要使用了堆排序，先建立一个长为`k`的最小堆，每次将堆顶按顺序放回到原数组中，然后要注意`n-k`位置后的元素个数会不足k个。并且堆排序要使用非递归形式，递归形式的空间复杂度是$O(logN)$。

#### 2. 重复值判断

题目描述如下：

> 请设计一个高效算法，判断数组中是否有重复值。必须保证额外空间复杂度为O(1)。
>
> 给定一个int数组**A**及它的大小**n**，请返回它是否有重复值。
>
> 测试样例：
>
> > [1,2,3,4,5,5,6],7
>
> > 返回：true

解法如下：

```c++
class Checker {
public:
    bool checkDuplicate(vector<int> a, int n) {
        // write code here
        // 建立一个最小堆
        buildHeap(a, n);
        // 排序
        for(int i=0; i<n; ++i){
            swap(a[n-i-1], a[0]);
            hSort(a, 0, n-i-1);
        }
        // 判断是否存在重复数值
        for(int i=1; i < n; ++i){
            if(a[i-1] == a[i])
                return true;
        } 
        return false;
    }
    void buildHeap(vector<int>& a, int n){
        for(int i= n/2-1; i >= 0; --i)
            hSort(a, i, n);
    }
    void hSort(vector<int>& A, int i, int n){
        int left = i * 2 + 1;
        while (left < n){
            // 对比左右子树，选择更小的数值
            if (left + 1 < n && A[left] > A[left + 1])
                left++;
            // 再与父结点进行比较
            if (A[i] < A[left])
                return;
            else{
                int tmp = A[left];
                A[left] = A[i];
                A[i] = tmp;
                // 此时就继续往下比较，用left作为父结点，进行比较
                i = left;
                left = i * 2 + 1;
            }
        }
    }
};
```

另一种解法，不满足空间复杂度的是如下：

```c++
class Checker {
public:
    bool checkDuplicate(vector<int> a, int n) {
        // write code here
        int min = a[0], max=a[0];
        // 查找数组中的最大值和最小值
        for(int i=1; i<n; ++i){
            min = (min < a[i])? min:a[i];
            max = (max > a[i])? max:a[i];
        }
        // 建立一个新的数组
        vector<int> tmp(max-min+1);
        // 统计每个索引值的数量，如果大于1，说明有重复值
        for(int i=0; i<n; ++i){
            if(++tmp[a[i]-min]>1)
                return true;
        }
        return false;
    }
};
```

这是一种新建一个数组，用于统计数组中每个数出现次数。

#### 3.  有序数组合并

题目如下：

> 有两个从小到大排序以后的数组A和B，其中A的末端有足够的缓冲空容纳B。请编写一个方法，将B合并入A并排序。
>
> 给定两个有序int数组**A**和**B**，A中的缓冲空用0填充，同时给定A和B的真实大小int **n**和int **m**，请返回合并后的数组。

解法如下：

```c++
class Merge {
public:
    int* mergeAB(int* A, int* B, int n, int m) {
        // write code here
        // 分别定义指向A和B数组尾元素位置的变量
        int pa = n-1, pb = m-1;
        // 定义指向A末尾刚好是两个数组大小的位置
        int p = n+m-1;
        while(pa>=0 && pb >= 0){
            // 通过比较，将较大数放在数组A末端
            A[p--] = (A[pa] >= B[pb])? A[pa--]:B[pb--];
        }
        // 如果数组B还有未进行比较的，直接复制到数组A前面
        while(pb >= 0)
            A[p--] = B[pb--];
        return A;
    }
};
```

这里采用从后往前进行比较来合并数组，并且注意如果数组A还有未进行比较的，可以直接跳过，而如果是数组B，则需要将其复制到数组A前面的相应位置。

#### 4. 三色排序

题目描述如下：

> 有一个只由0，1，2三种元素构成的整数数组，请使用交换、原地排序而不是使用计数进行排序。
>
> 给定一个只含0，1，2的整数数组**A**及它的大小，请返回排序后的数组。保证数组大小小于等于500。
>
> 测试样例：
>
> > [0,1,1,0,2,2],6
>
> > 返回：[0,0,1,1,2,2]

解法如下：

```c++
class ThreeColor {
public:
    vector<int> sortThreeColor(vector<int> A, int n) {
        // 数组左边设0区，右边设2区，把0放到数组0区，2放到数组2区，当遍历到2区时结束
        int start = 0, end = n-1;
        for(int i=0; i<n; ++i){
            if(i > end)
                break;
            if(A[i] == 0 && start < i)
                //交换后，下次判断还要为当前位置
                swap(A[i--], A[start++]);
            else if(A[i] == 2 && i < end)
                swap(A[i--], A[end--]);
        }
        return A;
    }
};
```

这是在左边设置0区，右边设置2区，即分别将0和2放到这两个区域，同时注意交换后还要判断交换过来的数值，以及这两个区的索引和当前进行循环的索引`i`大小的判断。

#### 5.  有序矩阵查找

题目如下：

> 现在有一个行和列都排好序的矩阵，请设计一个高效算法，快速查找矩阵中是否含有值x。
>
> 给定一个int矩阵**mat**，同时给定矩阵大小**n**x**m**及待查找的数**x**，请返回一个bool值，代表矩阵中是否存在x。所有矩阵中数字及**x**均为int范围内整数。保证**n**和**m**均小于等于1000。
>
> 测试样例：
>
> > [[1,2,3],[4,5,6],[7,8,9]],3,3,10
>
> > 返回：false

解法如下：

```c++
class Finder {
public:
    bool findX(vector<vector<int> > mat, int n, int m, int x) {
        if(n <= 0 || m <= 0 || mat.size() <= 0)
            return false;
        if(mat[0].size() <= 0)
            return false;
        // 从矩阵右上角开始查找
        int r = 0, c = m-1;
        while(r < n && c >= 0){
            if(mat[r][c] == x)
                return true;
            else if(mat[r][c] > x)
                --c;
            else
                ++r;
        }
        return false;
    }
};
```

上述解法是从矩阵右上角开始进行查找的。

#### 6. 最短子数组

题目如下：

> 对于一个数组，请设计一个高效算法计算需要排序的最短子数组的长度。
>
> 给定一个int数组**A**和数组的大小**n**，请返回一个二元组，代表所求序列的长度。(原序列位置从0开始标号,若原序列有序，返回0)。保证A中元素均为正整数。
>
> 测试样例：
>
> > [1,4,6,5,9,10],6
>
> > 返回：2

解法如下：

```c++
class Subsequence {
public:
    int shortestSubsequence(vector<int> A, int n) {
        int max=A[0], min=A[n-1];
        int rt=0, lt=0;
        // 从左到右遍历保存最大的数值，并记录比最大数要小的位置
        for(int i=0; i<n; ++i){
            max = (A[i] > max)? A[i] : max;
            rt = (A[i] < max)? i:rt;
        }
        // 从右到左遍历数组，保存最小值，并记录比最小值大的位置
        for(int i=n-1; i>=0; --i){
            min = (A[i] < min)? A[i]:min;
            lt = (A[i] > min)? i : lt;
        }
        return (rt != lt ? (rt-lt+1):0);
    }
};
```

先从左到右查找最大数，并记录比最大数小的位置，然后从右到左查找最小数，记录比最小数大的位置，判断两个位置是否相等，如果是，返回0，否则，则相减并加1。

#### 7.  相邻两数最大差值

题目如下：

> 有一个整形数组A，请设计一个复杂度为O(n)的算法，算出排序后相邻两数的最大差值。
>
> 给定一个int数组**A**和**A**的大小**n**，请返回最大的差值。保证数组元素多于1个。
>
> 测试样例：
>
> > [1,2,5,4,6],5
>
> > 返回：2

解法如下：

```c++
class Gap {
public:
    int maxGap(vector<int> A, int n) {
        int maxNum = getMax(A,n);
        // 建立一个桶
        vector<int> bucket(maxNum+1,0);
        // 统计数组中不同数值的个数
        for(int i=0; i<n; ++i){
            ++bucket[A[i]];
        }
        // 计算空缺的桶的索引值的差值
        int res = 0;
        int tmp = 0;
        for(int j=1; j<=maxNum; ++j){
            if(bucket[j] > 0){
                // 更新当前最大差值
                res = (res > tmp)? res:tmp;
                tmp = 0;
            }else{
                ++tmp;
            }
        }
        // 如果res!=0,需要加1
        return (res !=0)?(res+1) : res;
    }
    int getMax(vector<int> A, int n){
        int max=A[0];
        for(int i=1; i<n; ++i)
            max = (max > A[i])? max:A[i];
        return max;
    }
};
```

这是利用桶排序的思路，先根据数组最大值`maxNum`创建一个长度是`maxNum+1`的桶，然后根据数组元素的数值作为索引，找到其在桶中的位置，让对应位置的桶计数加1，之后通过空缺的桶的连续个数来得到数组相邻两数的最大差值。

------

### 字符串

#### 1. 词语变形

题目如下：

> 对于两个字符串A和B，如果A和B中出现的字符种类相同且每种字符出现的次数相同，则A和B互为变形词，请设计一个高效算法，检查两给定串是否互为变形词。
>
> 给定两个字符串**A**和**B**及他们的长度，请返回一个bool值，代表他们是否互为变形词。
>
> 测试样例：
>
> > "abc", 3, "bca", 3
>
> > 返回：true

解法如下：

```c++
class Transform {
public:
    bool chkTransform(string A, int lena, string B, int lenb) {
        // 分别建立两个数组作为哈希表
        char da[256] = {0}, db[256] = {0};
        // 分别统计两个数组的字符种类和出现个数
        for(int i=0; i<lena; ++i)
            ++da[A[i]];
        for(int j=0; j<lenb; ++j)
            ++db[B[j]];
        for(int k=0; k<256; ++k){
            if(da[k] != db[k])
                return false;
        }
        return true;
    }
};
```

这个方法主要是使用哈希表来分别统计两个数组的字符种类和出现次数，然后一一比较即可。

#### 2. 两串旋转

>如果对于一个字符串A，将A的前面任意一部分挪到后边去形成的字符串称为A的旋转词。比如A="12345",A的旋转词有"12345","23451","34512","45123"和"51234"。对于两个字符串A和B，请判断A和B是否互为旋转词。
>
>给定两个字符串**A**和**B**及他们的长度**lena**，**lenb**，请返回一个bool值，代表他们是否互为旋转词。
>
>测试样例：
>
> > cdab",4,"abcd",4
>
> > 返回：true

解法如下：

```c++
 bool chkRotation(string A, int lena, string B, int lenb) {
        // 先判断两个字符串是否长度相同
        if(lena != lenb)
            return false;
        if(A.size() <= 0 && B.size() > 0)
            return false;
        if(A.size() > 0 && B.size() <= 0)
            return false;
        // 拼接两个字符串A
        string str = A + A;
        int lens = lena + lena;
        int b_index = 0;
        for(int i=0; i < lens && b_index < lenb; ++i)
            // 遍历新字符串，寻找字符串B
            if(str[i] == B[b_index])
                ++b_index;
        return (b_index == lenb);
    }
```

上述解法是先判断两个字符串是否相等，相等的情况下，拼接两个字符串A得到一个新字符串，在这个新字符串中寻找是否存在字符串B。

另一个简洁的代码如下：

```c++
bool chkRotation(string A, int lena, string B, int lenb) {
        // write code here
        if(lena==lenb){
        //find函数的返回值是整数，假如字符串存在包含关系，其返回值必定不等于npos，但如果字符串不存在包含关系，
         //那么返回值就一定是npos
            string C=A+A;
            if(C.find(B)!= string::npos){
               return  true; 
            }  
        }
        return false;
    }
```



#### 3. 句子的逆序

> 对于一个字符串，请设计一个算法，只在字符串的单词间做逆序调整，也就是说，字符串由一些由空格分隔的部分组成，你需要将这些部分逆序。
>
> 给定一个原字符串**A**和他的长度，请返回逆序后的字符串。
>
> 测试样例：
>
> > "dog loves pig",13
>
> > 返回："pig loves dog"
>

解法如下：

```c++
string reverseSentence(string A, int n) {
        if(A.size() <= 0)
            return NULL;
        // 先翻转整个字符串
        reverse(A.begin(), A.end());
        int pBegin = 0, pEnd = 0;
        // 再逐个单词翻转
        while(pBegin < n){
            if(A[pBegin] == ' '){
                // 开头指针指向空格，两个指针同时增加
                ++pBegin;
                ++pEnd;
            }else if(A[pEnd] == ' ' || A[pEnd] == '\0'){
                // 尾指针指向空格或者结束符，都表示遇到一个单词
                reverse(A.begin()+pBegin, A.begin()+pEnd);
                pBegin = pEnd;
            }
            else{
                ++pEnd;
            }
        }
        return A;
    }
```

上述解法首先是旋转整个字符串，然后再逐个单词旋转。

#### 4. 字符串移位 

> 对于一个字符串，请设计一个算法，将字符串的长度为len的前缀平移到字符串的最后。
>
> 给定一个字符串**A**和它的长度，同时给定**len**，请返回平移后的字符串。
>
> 测试样例：
>
> > "ABCDE",5,3
>
> > 返回："DEABC"
>

解法如下：

```c++
string stringTranslation(string A, int n, int len) {
        if(A.size() <= 0)
            return "";
        // 先旋转前len个字符
        reverseString(A, 0, len-1);
        // 然后选择剩余字符串
        reverseString(A, len, n-1);
        // 最后选择整个字符串
        reverseString(A, 0, n-1);
        return A;
    }
    
    void reverseString(string& A, int start, int end){
        while(start < end){
            char tmp = A[start];
            A[start] = A[end];
            A[end] = tmp;
            ++start;
            --end;
        }
    }
```

首先选择需要平移的前`len`个字符，然后平移剩余字符串，最后再整个字符串进行翻转即可。

#### 5. 拼接最小字典序

> 对于一个给定的字符串数组，请找到一种拼接顺序，使所有小字符串拼接成的大字符串是所有可能的拼接中字典序最小的。
>
> 给定一个字符串数组**strs**，同时给定它的大小，请返回拼接成的串。
>
> 测试样例：
>
> > ["abc","de"],2
> >
> > "abcde"


解法如下：

```c++
string findSmallest(vector<string> strs, int n) {
        if(strs.size() <= 0)
            return "";
        // 通过组合进行排序
        sort(strs.begin(),strs.end(),compare);
        string result;
        for(int i=0;i<n;++i)
            result += strs[i];
        return result;
    }
    
    static bool compare(const string& a, const string& b){
        string str1 = a+b;
        string str2 = b+a;
        return (str1 < str2)? true:false;
    }
```

上述解法是定义一个比较函数，对两个字符串按不同顺序拼接后进行排序，根据排序后的结果来进行递增排序。

#### 6. 合法括号序列判断

> 对于一个字符串，请设计一个算法，判断其是否为一个合法的括号串。
>
> 给定一个字符串**A**和它的长度**n**，请返回一个bool值代表它是否为一个合法的括号串。
>
> 测试样例：
>
> > "(()())",6
>
> > 返回：true
>
>
> 测试样例：
>
> > "()a()()",7
>
> > 返回：false
>
> 测试样例：
>
> > "()(()()",7
> >
> > 返回：false
>

解法如下：

```c++
bool chkParenthesis(string A, int n) {
        // 记录左右括号数量的差值
        int num = 0;
        for(int i=0; i<n; ++i){
            if(A[i] == '(')
                ++num;
            else if(A[i] == ')')
                --num;
            else
                // 非法字符
                return false;
            if(num < 0)
                // 表示右括号多于左括号
                return false;
        }
        return (num == 0);
    }
```

使用一个整型变量记录左右括号数量的差值，根据差值判断是否合法。

#### 7. 空格替换

> 请编写一个方法，将字符串中的空格全部替换为“%20”。假定该字符串有足够的空间存放新增的字符，并且知道字符串的真实长度(小于等于1000)，同时保证字符串由大小写的英文字母组成。
>
> 给定一个string **iniString** 为原始的串，以及串的长度 int **len**, 返回替换后的string。
>
> 测试样例：
>
> > "Mr John Smith”,13
>
> > 返回："Mr%20John%20Smith"
>
> > ”Hello  World”,12
>
> > 返回：”Hello%20%20World”
>

解法如下：

```c++
class Replacement {
public:
    string replaceSpace(string iniString, int length) {
        if(iniString.size() <= 0)
            return "";
        int numBlanks=0;
        // 计算空格的数量
        for(int i=0; i<length;++i)
            if(iniString[i] == ' ')
                ++numBlanks;
        // 新长度
        int newLength = length + 2*numBlanks;
        string res(newLength,' ');
        int i = length-1, j = newLength-1;
        while(i >= 0){
            // 开始替换空格
            if(iniString[i] == ' '){
                res[j--] = '0';
                res[j--] = '2';
                res[j--] = '%';
            }else{
                res[j--] = iniString[i];
            }
            --i;
        }
        return res;
    }
};
```

需要先计算空格数量，然后新建一个新长度的字符串，并分别从两个字符串末尾开始往前遍历。

#### 8. 最长无重复字符子串

> 对于一个字符串,请设计一个高效算法，找到字符串的最长无重复字符的子串长度。
>
> 给定一个字符串**A**及它的长度**n**，请返回它的最长无重复字符子串长度。保证A中字符全部为小写英文字符，且长度小于等于500。
>
> 测试样例：
>
> > "aabcb",5
>
> > 返回：3
>

解法如下：

```c++
int longestSubstring(string A, int n) {
       //空间复杂度O（n），时间复杂度O（n）
       vector<int> map(26,-1);//保存当前字符出现的前一个位置
       vector<int> ans(n,0);//保存以i位置字符结尾的每最长无重复子串的长度
       int ret = 0;
 
       ans[0] = 1;
       map[A[0] - 'a'] = 0;
       for (int i = 1; i < n; i++) {
           // 计算当前位置的最长无重复子串是比较当前字符的上一个位置
           //和前一个字符位置得到的无重复子串长度的起始位置，取两者中最大值
           ans[i] = i - max(i - ans[i - 1], map[A[i] - 'a']+1) + 1;
           // 更新当前字符出现的最新位置
           map[A[i] - 'a'] = i;
           if (ret < ans[i]) 
               ret = ans[i];
       }
             
       return ret;
    }
```

上述解法使用了一个哈希表，用于记录当前字符出现的上个位置；再用一个数组记录以当前位置为字符结尾的最长无重复子串长度。每次循环的时候，最长无重复子串长度是根据当前字符上一个位置，以及前一个位置的最长无重复子串长度和当前位置差值，取这两个数值的最大值。

------

### 队列和栈

#### 1. 可查询最值的栈

> 定义栈的数据结构，请在该类型中实现一个能够得到栈最小元素的min函数

解法如下：

```c++
class Solution {
private:
    stack<int> data;
    stack<int> min_d;
public:
    void push(int value) {
        if(min_d.size() <= 0 || value < min_d.top()){
            // 当待插入数值小于min_d栈顶元素或者min_d是空，压入min_d中
            min_d.push(value);
        }else{
            min_d.push(min_d.top());
        }
        data.push(value);
    }
    void pop() {
        if(data.size() > 0 && min_d.size() > 0){
            data.pop();
            min_d.pop();
        }
    }
    int top() {
        return data.top();
    }
    int min() {
        return min_d.top();
    }
};
```

采用两个栈实现，一个栈保存插入的数据，一个栈保存当前最小值。

#### 2. 双栈队列

> 编写一个类,只能用两个栈结构实现队列,支持队列的基本操作(push，pop)。
>
> 给定一个操作序列**ope**及它的长度**n**，其中元素为正数代表push操作，为0代表pop操作，保证操作序列合法且一定含pop操作，请返回pop的结果序列。
>
> 测试样例：
>
> > [1,2,3,0,4,0],6
>
> > 返回：[1,2]
>

解法如下：

```c++
class TwoStack {
private:
    stack<int> s1;
    stack<int> s2;
public:
    vector<int> twoStack(vector<int> ope, int n) {
        if(ope.size() <= 0)
            return vector<int>();
        vector<int> res;
        for(int i=0; i<n; ++i){
            if(ope[i] == 0)
                res.push_back(pop());
            else
                push(ope[i]);
        }
        return res;
    }
    
    void push(int val){
        // s1专门用于保存插入的数据
        s1.push(val);
    }
    int pop(){
        if(s2.empty()){
            // s2是空的时候，将s1的元素都压入s2，并弹出s2的栈顶
            while(!s1.empty()){
                int tmp = s1.top();
                s1.pop();
                s2.push(tmp);
            }
        }
        int res = s2.top();
        s2.pop();
        return res;
    }
};
```

用两个栈实现队列，其中栈1专门用来保存`push`的数值，而栈2则是用于`pop`操作，它是将栈1中的元素都压入，这样栈2弹出的顺序就是所有元素压入的顺序，实现了队列的先进先出的特性。

#### 3. 栈的反转

> 实现一个栈的逆序，但是只能用递归函数和这个栈本身的pop操作来实现，而不能自己申请另外的数据结构。
>
> 给定一个整数数组**A**即为给定的栈，同时给定它的大小**n**，请返回逆序后的栈。
>
> 测试样例：
>
> > [4,3,2,1],4
>
> > 返回：[1,2,3,4]
>

解法如下：

```c++
class StackReverse {
public:
    vector<int> reverseStack(vector<int> A, int n) {
        int top = n-1;
        reverse(A, top);
        return A;
    }
    int pop(vector<int>& A, int& top){
        int val = A[top--];
        return val;
    }
    void push(vector<int>& A, int& top, int val){
        A[++top] = val;
    }
    // 移除栈顶元素，并返回它
    int removeBottom(vector<int>& A, int& top){
        int res = pop(A,top);
        if(top < 0){
            return res;
        }else{
            int bottom = removeBottom(A, top);
            // 压回非栈底元素
            push(A, top, res);
            return bottom;
        }
    }
    // 反转栈
    void reverse(vector<int>& A, int& top){
        if(top < 0){
            return;
        }else{
            // 得到栈底元素
            int res = removeBottom(A, top);
            reverse(A, top);
            // 将栈底元素放到最前
            push(A, top, res);
        }
    }
};
```

上述解法主要是`removeBottom`函数和`reverse`两个函数，前者是移除栈中的栈底元素，并返回它，而其他元素则按原来顺序存放在栈中，而`reverse`函数则是实现反转的操作。

#### 4. 双栈排序

> 请编写一个程序，按升序对栈进行排序（即最大元素位于栈顶），要求最多只能使用一个额外的栈存放临时数据，但不得将元素复制到别的数据结构中。
>
> 给定一个int[] **numbers**(C++中为vector<int>)，其中第一个元素为栈顶，请返回排序后的栈。请注意这是一个栈，意味着排序过程中你只能访问到第一个元素。
>
> 测试样例：
>
> > [1,2,3,4,5]
>
> > 返回：[5,4,3,2,1]
>

解法如下：

```c++
class TwoStacks {
public:
    vector<int> twoStacksSort(vector<int> numbers) {
        if(numbers.size() <= 0)
            return vector<int>();
        // 使用一个临时栈，从栈底到栈顶是降序，即最小值在栈顶
        stack<int> s;
        int i=0;
        while( i<numbers.size()){
            if(s.empty() || numbers[i] >= s.top()){
                // 临时栈为空或者大于栈顶元素，则压入
                s.push(numbers[i]);
            	++i;
        	}
     		else{
                // 将较小的当前元素放到前一个位置
                numbers[i-1] = numbers[i];
                // 将较大的栈顶元素放到当前位置，然后从i-1位置开始再次循环
                numbers[i] = s.top();
                s.pop();
                --i;
            }
        }
        // 将排序好的临时栈依次放回原栈中
        for(int i=0; i<numbers.size(); ++i){
            numbers[i] = s.top();
            s.pop();
        }
        return numbers;
    }
};
```

上述算法利用一个辅助栈来实现对栈元素的排序。

#### 5. 滑动窗口

> 有一个整型数组 arr 和一个大小为 w 的窗口从数组的最左边滑到最右边,窗口每次向右边滑一个位置。 返回一个长度为n-w+1的数组res，res[i]表示每一种窗口状态下的最大值。 以数组为[4,3,5,4,3,3,6,7]，w=3为例。因为第一个窗口[4,3,5]的最大值为5，第二个窗口[3,5,4]的最大值为5，第三个窗口[5,4,3]的最大值为5。第四个窗口[4,3,3]的最大值为4。第五个窗口[3,3,6]的最大值为6。第六个窗口[3,6,7]的最大值为7。所以最终返回[5,5,5,4,6,7]。
>
> 给定整形数组**arr**及它的大小**n**，同时给定**w**，请返回res数组。保证**w**小于等于**n**，同时保证数组大小小于等于500。
>
> 测试样例：
>
> > [4,3,5,4,3,3,6,7],8,3
>
> > 返回：[5,5,5,4,6,7]
>

解法如下：

```c++
vector<int> slide(vector<int> arr, int n, int w) {
        // 定义一个队列保存数组下标
        deque<int> ins;
        vector<int> res;
        if(n >= w && w >= 1){
            // 初始滑动窗口
            for(unsigned int i = 0; i<w; ++i){
                while(!ins.empty() && arr[i] >= arr[ins.back()])
                    // 队列末尾元素小于当前元素，则弹出
                    ins.pop_back();
                ins.push_back(i);
            }
            // 继续滑动窗口
            for(unsigned int i = w; i<n; ++i){
                // 保存队列头部元素
                res.push_back(arr[ins.front()]);
                while(!ins.empty() && arr[i] >= arr[ins.back()])
                    // 队列末尾元素小于当前元素，则弹出
                    ins.pop_back();
                while(!ins.empty() && ins.front() <=(int)(i-w))
                    // 队列头部超出滑动窗口范围
                    ins.pop_front();
                ins.push_back(i);
            }
            res.push_back(arr[ins.front()]);
        }
        return res;
    }
```

利用一个队列保存滑动窗口中元素的下标，这个元素是当前窗口中的最大值以及可能成为最大值的结果。因此，队列首部必然是最大值，而末尾元素如果小于新进入的元素，则会被弹出队列中。滑动过程还要注意队列头部的下标是否超过滑动窗口范围，需要及时弹出。同时考虑最后一个窗口的最大值要记得保存。

#### 6. 数组变树

> 对于一个没有重复元素的整数数组，请用其中元素构造一棵MaxTree，MaxTree定义为一棵二叉树，其中的节点与数组元素一一对应，同时对于MaxTree的每棵子树，它的根的元素值为子树的最大值。现有一建树方法，对于数组中的每个元素，其在树中的父亲为数组中它左边比它大的第一个数和右边比它大的第一个数中更小的一个。若两边都不存在比它大的数，那么它就是树根。请设计O(n)的算法实现这个方法。
>
> 给定一个无重复元素的数组**A**和它的大小**n**，请返回一个数组，其中每个元素为原数组中对应位置元素在树中的父亲节点的编号，若为根则值为-1。
>
> 测试样例：
>
> > [3,1,4,2],4
>
> > 返回：[2,0,-1,2]
>

解法如下：

```c++
class MaxTree {
public:
    vector<int> buildMaxTree(vector<int> A, int n) {
        // 定义两个数组分别存放左边第一个大和右边第一个大的数
        vector<int> left(n);
        vector<int> right(n);
        vector<int> res;
        // 两个栈，用来辅助寻找左右第一个比当前元素大的数值
        stack<int> s1;
        stack<int> s2;
        for(int i=0; i<n; ++i){
            // 寻找左边第一个比A[i]大的元素
            while(!s1.empty() && A[i] > A[s1.top()]){
                // 当前元素大于栈顶元素，则弹出栈顶
                s1.pop();
            }
            if(!s1.empty()){
                // 栈顶元素就是左边第一个大的元素
                left[i] = s1.top();
            }else{
                // 否则，左边没有找到大于自己的元素
                left[i] = -1;
            }
            s1.push(i);
        }
        // 接下来寻找右边第一个比自己大的数
        for(int i=n-1; i>=0; --i){
            while(!s2.empty() && A[i] > A[s2.top()]){
                // 当前元素大于栈顶元素，则弹出栈顶
                s2.pop();
            }
            if(!s2.empty()){
                // 栈顶元素就是右边第一个大的元素
                right[i] = s2.top();
            }else{
                // 否则，右边没有找到大于自己的元素
                right[i] = -1;
            }
            s2.push(i);
        }
        // 进行比较，确定每个数组位置上父结点的位置
        for(int i=0; i<n; ++i){
            // 对比左右两个数，哪个更小
            if(left[i] == -1 && right[i] == -1)
                res.push_back(-1);
            else if(left[i] == -1)
                res.push_back(right[i]);
            else if(right[i] == -1)
                res.push_back(left[i]);
            else{
                int ind = (A[left[i]] <= A[right[i]])? left[i]:right[i];
            	res.push_back(ind);
            }
        }
        return res;
    }
};
```

这道题目需要找到当前元素左右两边第一个大于自己的元素，分别用两个栈进行辅助，当前元素如果小于栈顶元素，则压入栈中，否则就一直弹出栈顶元素，直到找到大于当前元素的栈顶元素为止。最后是比较左右两边的元素，取最小值的下标。

------

### 位运算

#### 1. 交换练习

> 给定一个数组**num**，其中包含两个值，请不用任何额外变量交换这两个值，并将交换后的数组返回。
>
> 测试样例：
>
>
> > [1,2]
>
> > 返回：[2,1]

解法如下：

```c++
vector<int> getSwap(vector<int> num) {
        // 使用异或交换两个数
        num[0] ^= num[1];
        num[1] ^= num[0];
        num[0] ^= num[1];
        return num;
}
```

使用异或方法进行交换两个数。

#### 2. 比较练习

> 对于两个32位整数a和b，请设计一个算法返回a和b中较大的。但是不能用任何比较判断。若两数相同，返回任意一个。
>
> 给定两个整数**a**和**b**，请返回较大的数。
>
> 测试样例：
>
> > 1,2
>
> > 返回：2

解法如下：

```c++
int getMax(int a, int b) {
        // 获取两个数的差值
        int c = a - b;
        // 查看符号位，如果是负数，结果是1，正数是0
        int flag = (c>>31) & 1;
        // flag是负数，返回b，是正数，则返回a
        return b*flag + a*(flag ^ 1);
}
```

解法主要是判断两个整数差值的符号位。

#### 3. 寻找奇数出现

> 有一个整型数组A，其中只有一个数出现了奇数次，其他的数都出现了偶数次，请打印这个数。要求时间复杂度为O(N)，额外空间复杂度为O(1)。
>
> 给定整形数组**A**及它的大小**n**，请返回题目所求数字。
>
> 测试样例：
>
> > [1,2,3,2,1],5
>
> > 返回：3

解法如下：

```c++
int findOdd(vector<int> A, int n) {
        int res = A[0];
        // 对每个数都进行异或，最终结果就是只出现奇数次的数字
        for(int i=1; i<n; ++i)
            res ^= A[i];
        return res;
    }
```

使用异或运算，偶数次的元素会变成0，剩下的结果就是奇数次的数。

#### 4. 奇数出现2

> 给定一个整型数组arr，其中有两个数出现了奇数次，其他的数都出现了偶数次，找到这两个数。要求时间复杂度为O(N)，额外空间复杂度为O(1)。
>
> 给定一个整形数组**arr**及它的大小**n**，请返回一个数组，其中两个元素为两个出现了奇数次的元素,请将他们按从小到大排列。
>
> 测试样例：
>
> > [1,2,4,4,2,1,3,5],8
>
> > 返回：[3,5]

解法如下：

```c++
class OddAppearance {
public:
    vector<int> findOdds(vector<int> arr, int n) {
        int res = 0;
        for(int i=0; i<n; ++i)
            res ^= arr[i];
        unsigned int indexOf1 = findBitsOf1(res);
        vector<int> r(2,0);
        for(int j=0; j<n; ++j){
            // 根据indexOf1位上是否为1分成两组
            if(isBit1(arr[j],indexOf1))
                r[0] ^= arr[j];
            else
                r[1] ^= arr[j];
        }
        sort(r.begin(), r.end());
        return r;
    }
    
    // 寻找出现1的位数
    unsigned int findBitsOf1(int n){
        int count = 0;
        while((n & 1) == 0 && count < sizeof(int) * 8){
            ++count;
            n = n >> 1;
        }
        return count;
    }
    // 判断给定的位数上是否为1
    bool isBit1(int n, unsigned int index){
        n = n >> index;
        return (n & 1);
    }
};
```

这个方法也是使用了异或，对数组的所有元素都进行异或后，得到的结果由于有两个数是奇数次，所以不为0，因此先找出第一个为1的位，根据这个将数组分成两部分，分别进行异或就可以得到结果。

