## 面试算法题总结

------

### 排序算法

#### 冒泡排序

冒泡排序是两两进行比较，将较大值往后移动。

```c++
class BubbleSort {
public:
    int* bubbleSort(int* A, int n) {
        if(n <= 0)
            return NULL;
        for(int i=0; i<n-1;++i){
            for(int j=0; j<n-i-1;++j){
                // 从前往后比较，将最大值移动到末尾
                if(A[j]>A[j+1]){
                    swap(A[j],A[j+1]);
                }
            }
        }
        return A;
    }
};

// 改进版冒泡算法
int* BubbleSortOptimz(int* A, int n){
	int i, j;
	bool flag = true;
	for (int i = 0; i < n-1 && flag; i++){
		// 若 flag为false则退出循环
		flag = false;
		for (j = 0; j < n-1-i; --j){
			if (A[j] > A[j+1]){
				// 实现递增排序
				swap(A, j, j + 1);
				// 如果有数据交换，则flag是true
				flag = true;
			}
		}
	}
  	return A;
}
```

#### 选择排序

选择排序是每次在给定范围内搜索最小值，然后将其交换到当前范围的头部，所以第一次搜索范围是整个数组，搜索最小值交换到第一个位置，接着从第二个位置开始搜索整个数组的第二小的数值交换到第二个位置，依次进行。所以整个过程，交换次数只有n-1次。

```c++
class SelectionSort {
public:
    int* selectionSort(int* A, int n) {
        // write code here
        int i, j, min;
        for(i=0; i < n-1; ++i){
            min = i;
            // 在后面的元素中进行比较，并保存最小元素的索引值
            for(j= i+1; j < n; ++j)
                if(A[min] > A[j])
                    min = j;
            // 进行交换，选择排序每次外层循环中只进行一次交换
            int tmp = A[min];
            A[min] = A[i];
            A[i] = tmp;
        }
        return A;
    }
};
```

#### 插入排序

选择第i个元素，依次跟前面的元素进行比较，当前面的元素比它大，则将更大的元素往后移动，不断比较直到遇到小于它的元素。

```c++
class InsertionSort {
public:
    int* insertionSort(int* A, int n) {
        // write code here
        if(n <= 0)
            return A;
        int tmp;
        for(int i=1; i<n; i++){
            tmp = A[i];
            int j = i-1; 
            // 如果 i 前面的元素都比A[i]大，则依次往后移动，直到一个小于A[i]的位置
            while(j >= 0 && A[j] > tmp){
                A[j+1] = A[j];
                --j;
            }
            A[j+1] = tmp;
        }
        return A;
    }
};
```

#### 归并排序

递归实现：将n长度的数组分解成n/2长度，接着继续对半分解，直到得到长度为1的子数组，并两两进行比较，然后合并成一个更长的数组，依次合并，最终得到原数组，并且是一个排序好的数组。

```c++
class MergeSort {
public:
    int* mergeSort(int* A, int n) {
        if(n <= 0)
            return NULL;
        int* tmp = new int[n];
        MergeSortInner(A,0, n-1,tmp);
        delete[] tmp;
        return A;
    }
    void MergeSortInner(int* A, int start, int end,int* tmp){
        if(start < end){
            int mid = (start+end)/2;
            // 令左边有序
            MergeSortInner(A,start, mid, tmp);
            // 令右边有序
            MergeSortInner(A,mid+1, end, tmp);
            // 合并
            merge(A, start, mid, end, tmp);
        }
    }
    void merge(int* A, int start, int mid, int end, int* tmp){
        // 定义左边开始和结尾位置
        int i = start, ie = mid;
        // 右边起始和结束位置
        int j = mid+1, je = end;
        // 进行比较，然后在tmp数组中进行排序
        int k=0;
        while(i <= ie && j <= je){
            if(A[i] < A[j]){
                tmp[k++] = A[i++];
            }else{
                tmp[k++] = A[j++];
            }
        }
        // 复制剩下的元素
        while(i <= ie)
            tmp[k++] = A[i++];
        while(j <= je)
            tmp[k++] = A[j++];
        // 将tmp排序好的部分复制回原数组中
        for(int l=0; l<k; ++l)
            A[start+l] = tmp[l];
    }
};
```

迭代实现版本：

迭代实现则是自底向上，先依次比较长度为1的子数组，然后升级到长度为2，依次增加子数组长度，直到到达数组长度为止。

```c++
// 迭代实现归并排序
int* mergeSort(int* A, int n) {
	// write code here
	int *tmp = new int[n];

	for (int size = 1; size < n; size *= 2){
		// size 是控制每个分块的大小，先从1开始，每次加倍增加，即从1，2，4...直到整个数组长度为止
		for (int start = 0; start < n; start += size + size){
			int k = start;
			// 设置一个分块的起始、中间和结束位置，通过size来控制
			int left = start, mid = min(left + size, n), right = min(left + size + size, n);

			int start1 = left, end1 = mid;
			int start2 = mid, end2 = right;
			// 通过tmp数组来对分块内的两个部分进行排序
			while (start1 < end1 && start2 < end2)
				tmp[k++] = (A[start1] < A[start2]) ? A[start1++] : A[start2++];
			while (start1 < end1)
				tmp[k++] = A[start1++];
			while (start2 < end2)
				tmp[k++] = A[start2++];
			// 将排序好的部分赋回原数组A
			for (int j = left; j < right; ++j)
				A[j] = tmp[j];
		}
	}
	delete[] tmp;
	return A;
}
```



#### 快速排序

```c++
class QuickSort {
public:
    int* quickSort(int* A, int n) {
        if(n <= 0)
            return NULL;
        qSort(A,0,n-1);
        return A;
    }
    void qSort(int* A, int start, int end){
        if(start < end){
            // 取第一个值为基准值
            int privot = A[start];
            int low = start;
            int high = end;
            while(low < high){
                while(high > low && A[high] >= privot)
                    // 从后往前寻找小于privot的元素
                    --high;
                if(low < high)
                    A[low++] = A[high];
                while(low < high && A[low] <= privot)
                    ++low;
                if(low < high)
                    A[high--] = A[low];
            }
            A[low] = privot;
            qSort(A,start, low-1);
            qSort(A, low+1, end);
        }
    }
};
```

#### 堆排序

```c++
void hSort(int *A, int i, int n){
	int left = i * 2 + 1;
	while (left < n){
		// 对比左右子树，选择更大的数值
		if (left + 1 < n && A[left] < A[left + 1])
			left++;
		// 再与父结点进行比较
		if (A[i] > A[left])
			return;
		else{
			int tmp = A[left];
			A[left] = A[i];
			A[i] = tmp;
			// 此时就继续往下比较，用left作为父结点，进行比较
			i = left;
			left = i * 2 + 1;
		}
	}
}

int* heapSort(int* A, int n) {
	// write code here
	// 首先开始建立一个最大堆，从最后一个非叶结点开始
	for (int i = n / 2 - 1; i >= 0; --i)
		hSort(A, i, n);
	 // 再开始进行堆排序
	for (int i = n - 1; i >= 0; --i){
		// 每次先将堆顶元素和末尾元素交换，再进行堆排序
		int tmp = A[0];
		A[0] = A[i];
		A[i] = tmp;
		// 每次将最大数值放到堆顶，交换后，最大值就放到数组末尾了。
		hSort(A, 0, i);
	}
	return A;
}

```

递归版本的堆排序的代码只需要修改`hSort`函数：

```c++
// 递归版本的堆排序
void hSort(int* A, int start, int end){
        int left = start*2+1;
        int right = left+1;
        int largest = start;
        if(left < end && A[start] < A[left])
            largest = left;
        if(right < end && A[largest]<A[right])
            largest = right;
        if(largest != start){
            swap(A[start],A[largest]);
        	hSort(A, largest, end);
        }
    }
```

#### 希尔排序

```c++
class ShellSort {
public:
    int* shellSort(int* A, int n) {
        // write code here
        // 选择初始增量为数组长度的一半
        int gap = n/2;
        while(gap > 0){
            for(int i=gap; i<n; ++i){
                // 起始位置从gap开始
                int tmp = A[i];
                int j = i-gap;
                // 每次比较的增加或减少都是 gap
                while(j >= 0 && A[j] > tmp){
                    A[j+gap] = A[j];
                    j -= gap;
                }
                A[j+gap] = tmp;
            }
            // 逐步缩小增量，直到等于1为止。
            gap /= 2;
        }
        return A;
    }
};
```

#### 计数排序

```c++
class CountingSort {
public:
    int* countingSort(int* A, int n) {
        if(n <= 0)
            return NULL;
        int maxV = getMax(A,n)+1;
        // 创建长度为maxV的桶
        vector<int> res(maxV,0);
        for(int i=0; i<n;++i){
            // 统计每个数值在数组中出现的次数
            res[A[i]]++;
        }
        // 排序
        int k=0;
        for(int i=0; i<maxV;++i){
            for(int j=0; j<res[i];++j)
                A[k++] = i;
        }
        return A;
    }
    int getMax(int* A, int n){
        // 返回最大值
        int res = A[0];
        for(int i=1; i<n; ++i)
            res = (A[i] > res)? A[i]:res;
        return res;
    }
};
```

#### 基数排序

```c++
class RadixSort {
public:
    int* radixSort(int* A, int n) {
        if(n <= 0)
            return NULL;
        int maxBits_ = maxBits(A,n);
        // 相除的最大数
        int bits = pow(10, maxBits_-1);
        // 建立10个桶，对应位数是0-9
        vector<int> res[10];
        int c = 1;
        while(c <= bits){
            for(int i=0; i<n; ++i){
                // 遍历数组，依次求取对应位数上的数值并存放到对应的桶中
                int lgd = (A[i] / c) %10;
                res[lgd].push_back(A[i]);
            }
            // 重新排序
            int k=0;
            for(int i=0; i<10; ++i){
                for(int m=0; m<res[i].size(); ++m)
                    A[k++] = res[i][m];
                res[i].clear();
            }
            // 准确计算更高一位的数值
            c *= 10;  
        }
        return A;
    }
    // 统计数组中元素的最大位数
    int maxBits(int* A, int n){
        int _max = 0;
        for(int i=0;i<n; ++i){
            int d = 0;
            int a = A[i];
            // 统计当前元素的位数
            while(a){
                a /= 10;
                ++d;
            }
            _max = (d>_max)? d:_max;
        }
        return _max;
    }
};
```

#### 桶排序

```c++
void BucketSort(int * arr, int n)
{
	vector<int> bucket[10];
	for (int i = 0; i < n; i++)
	{
		int temp = arr[i];
		int flag = (int)(arr[i] / 10); //flag标识小数的第一位   
		bucket[flag].push_back(temp); //用二维数组的每个向量来存放小数第一位相同的数据  
		int j = bucket[flag].size() - 1;

		/* 利用插入排序对每一行进行排序 */
		for (; j > 0 && temp < bucket[flag][j - 1]; --j)
		{
			bucket[flag][j] = bucket[flag][j - 1];
		}
		bucket[flag][j] = temp;
	}

	/* 所有数据重新链接 */
	int k = 0;
	for (int i = 0; i < 10; i++)
	{
		for (int j = 0; j< bucket[i].size(); j++)
		{
			arr[k++] = bucket[i][j];
		}
	}
}

```



#### 1. 小范围排序

题目描述如下：

> 已知一个几乎有序的数组，几乎有序是指，如果把数组排好顺序的话，每个元素移动的距离可以不超过k，并且k相对于数组来说比较小。请选择一个合适的排序算法针对这个数据进行排序。
>
> 给定一个int数组**A**，同时给定A的大小**n**和题意中的**k**，请返回排序后的数组。
>
> 测试样例：
>
> > [2,1,4,3,6,5,8,7,10,9],10,2
>
> > 返回：[1,2,3,4,5,6,7,8,9,10]

解法如下：

```c++
class ScaleSort {
public:
    vector<int> sortElement(vector<int> A, int n, int k) {
        // write code here
        // 建立一个最小堆
        vector<int>  myheap(A.begin(), A.begin() + k);
        buildHeap(myheap, k);
        // 每次弹出堆顶，并加入下一个元素，即i+k
        for (int i = 0; i != n - k; i++){
            A[i] = myheap[0];
            myheap[0] = A[i + k];
            heapSort(myheap, 0, k);
        }
        // 对于剩下的n-k 到 n-1位置的元素的处理
        for (int i = 0; i != k; i++){
            // 起始位置是从 n-k 开始的
            A[i + n - k] = myheap[0];
            // 堆内将堆顶和堆后面的元素依次交换
            myheap[0] = myheap[k - 1 - i];
            heapSort(myheap, 0, k - i);
        }
        return A;
        
    }
    // 建堆
    void buildHeap(vector<int>& a, int k){
        for(int i=k/2 -1; i>=0; --i)
            heapSort(a, i, k);
    }
    void heapSort(vector<int>& A, int i, int n){
        int left = i * 2 + 1;
        while (left < n){
            // 对比左右子树，选择更小的数值
            if (left + 1 < n && A[left] > A[left + 1])
                left++;
            // 再与父结点进行比较
            if (A[i] < A[left])
                return;
            else{
                int tmp = A[left];
                A[left] = A[i];
                A[i] = tmp;
                // 此时就继续往下比较，用left作为父结点，进行比较
                i = left;
                left = i * 2 + 1;
            }
        }
    }  
};
```

上述解法主要使用了堆排序，先建立一个长为`k`的最小堆，每次将堆顶按顺序放回到原数组中，然后要注意`n-k`位置后的元素个数会不足k个。并且堆排序要使用非递归形式，递归形式的空间复杂度是$O(logN)$。

#### 2. 重复值判断

题目描述如下：

> 请设计一个高效算法，判断数组中是否有重复值。必须保证额外空间复杂度为O(1)。
>
> 给定一个int数组**A**及它的大小**n**，请返回它是否有重复值。
>
> 测试样例：
>
> > [1,2,3,4,5,5,6],7
>
> > 返回：true

解法如下：

```c++
class Checker {
public:
    bool checkDuplicate(vector<int> a, int n) {
        // write code here
        // 建立一个最小堆
        buildHeap(a, n);
        // 排序
        for(int i=0; i<n; ++i){
            swap(a[n-i-1], a[0]);
            hSort(a, 0, n-i-1);
        }
        // 判断是否存在重复数值
        for(int i=1; i < n; ++i){
            if(a[i-1] == a[i])
                return true;
        } 
        return false;
    }
    void buildHeap(vector<int>& a, int n){
        for(int i= n/2-1; i >= 0; --i)
            hSort(a, i, n);
    }
    void hSort(vector<int>& A, int i, int n){
        int left = i * 2 + 1;
        while (left < n){
            // 对比左右子树，选择更小的数值
            if (left + 1 < n && A[left] > A[left + 1])
                left++;
            // 再与父结点进行比较
            if (A[i] < A[left])
                return;
            else{
                int tmp = A[left];
                A[left] = A[i];
                A[i] = tmp;
                // 此时就继续往下比较，用left作为父结点，进行比较
                i = left;
                left = i * 2 + 1;
            }
        }
    }
};
```

另一种解法，不满足空间复杂度的是如下：

```c++
class Checker {
public:
    bool checkDuplicate(vector<int> a, int n) {
        // write code here
        int min = a[0], max=a[0];
        // 查找数组中的最大值和最小值
        for(int i=1; i<n; ++i){
            min = (min < a[i])? min:a[i];
            max = (max > a[i])? max:a[i];
        }
        // 建立一个新的数组
        vector<int> tmp(max-min+1);
        // 统计每个索引值的数量，如果大于1，说明有重复值
        for(int i=0; i<n; ++i){
            if(++tmp[a[i]-min]>1)
                return true;
        }
        return false;
    }
};
```

这是一种新建一个数组，用于统计数组中每个数出现次数。

#### 3.  有序数组合并

题目如下：

> 有两个从小到大排序以后的数组A和B，其中A的末端有足够的缓冲空容纳B。请编写一个方法，将B合并入A并排序。
>
> 给定两个有序int数组**A**和**B**，A中的缓冲空用0填充，同时给定A和B的真实大小int **n**和int **m**，请返回合并后的数组。

解法如下：

```c++
class Merge {
public:
    int* mergeAB(int* A, int* B, int n, int m) {
        // write code here
        // 分别定义指向A和B数组尾元素位置的变量
        int pa = n-1, pb = m-1;
        // 定义指向A末尾刚好是两个数组大小的位置
        int p = n+m-1;
        while(pa>=0 && pb >= 0){
            // 通过比较，将较大数放在数组A末端
            A[p--] = (A[pa] >= B[pb])? A[pa--]:B[pb--];
        }
        // 如果数组B还有未进行比较的，直接复制到数组A前面
        while(pb >= 0)
            A[p--] = B[pb--];
        return A;
    }
};
```

这里采用从后往前进行比较来合并数组，并且注意如果数组A还有未进行比较的，可以直接跳过，而如果是数组B，则需要将其复制到数组A前面的相应位置。

#### 4. 三色排序

题目描述如下：

> 有一个只由0，1，2三种元素构成的整数数组，请使用交换、原地排序而不是使用计数进行排序。
>
> 给定一个只含0，1，2的整数数组**A**及它的大小，请返回排序后的数组。保证数组大小小于等于500。
>
> 测试样例：
>
> > [0,1,1,0,2,2],6
>
> > 返回：[0,0,1,1,2,2]

解法如下：

```c++
class ThreeColor {
public:
    vector<int> sortThreeColor(vector<int> A, int n) {
        // 数组左边设0区，右边设2区，把0放到数组0区，2放到数组2区，当遍历到2区时结束
        int start = 0, end = n-1;
        for(int i=0; i<n; ++i){
            if(i > end)
                break;
            if(A[i] == 0 && start < i)
                //交换后，下次判断还要为当前位置
                swap(A[i--], A[start++]);
            else if(A[i] == 2 && i < end)
                swap(A[i--], A[end--]);
        }
        return A;
    }
};
```

这是在左边设置0区，右边设置2区，即分别将0和2放到这两个区域，同时注意交换后还要判断交换过来的数值，以及这两个区的索引和当前进行循环的索引`i`大小的判断。

#### 5.  有序矩阵查找

题目如下：

> 现在有一个行和列都排好序的矩阵，请设计一个高效算法，快速查找矩阵中是否含有值x。
>
> 给定一个int矩阵**mat**，同时给定矩阵大小**n**x**m**及待查找的数**x**，请返回一个bool值，代表矩阵中是否存在x。所有矩阵中数字及**x**均为int范围内整数。保证**n**和**m**均小于等于1000。
>
> 测试样例：
>
> > [[1,2,3],[4,5,6],[7,8,9]],3,3,10
>
> > 返回：false

解法如下：

```c++
class Finder {
public:
    bool findX(vector<vector<int> > mat, int n, int m, int x) {
        if(n <= 0 || m <= 0 || mat.size() <= 0)
            return false;
        if(mat[0].size() <= 0)
            return false;
        // 从矩阵右上角开始查找
        int r = 0, c = m-1;
        while(r < n && c >= 0){
            if(mat[r][c] == x)
                return true;
            else if(mat[r][c] > x)
                --c;
            else
                ++r;
        }
        return false;
    }
};
```

上述解法是从矩阵右上角开始进行查找的。

#### 6. 最短子数组

题目如下：

> 对于一个数组，请设计一个高效算法计算需要排序的最短子数组的长度。
>
> 给定一个int数组**A**和数组的大小**n**，请返回一个二元组，代表所求序列的长度。(原序列位置从0开始标号,若原序列有序，返回0)。保证A中元素均为正整数。
>
> 测试样例：
>
> > [1,4,6,5,9,10],6
>
> > 返回：2

解法如下：

```c++
class Subsequence {
public:
    int shortestSubsequence(vector<int> A, int n) {
        int max=A[0], min=A[n-1];
        int rt=0, lt=0;
        // 从左到右遍历保存最大的数值，并记录比最大数要小的位置
        for(int i=0; i<n; ++i){
            max = (A[i] > max)? A[i] : max;
            rt = (A[i] < max)? i:rt;
        }
        // 从右到左遍历数组，保存最小值，并记录比最小值大的位置
        for(int i=n-1; i>=0; --i){
            min = (A[i] < min)? A[i]:min;
            lt = (A[i] > min)? i : lt;
        }
        return (rt != lt ? (rt-lt+1):0);
    }
};
```

先从左到右查找最大数，并记录比最大数小的位置，然后从右到左查找最小数，记录比最小数大的位置，判断两个位置是否相等，如果是，返回0，否则，则相减并加1。

#### 7.  相邻两数最大差值

题目如下：

> 有一个整形数组A，请设计一个复杂度为O(n)的算法，算出排序后相邻两数的最大差值。
>
> 给定一个int数组**A**和**A**的大小**n**，请返回最大的差值。保证数组元素多于1个。
>
> 测试样例：
>
> > [1,2,5,4,6],5
>
> > 返回：2

解法如下：

```c++
class Gap {
public:
    int maxGap(vector<int> A, int n) {
        int maxNum = getMax(A,n);
        // 建立一个桶
        vector<int> bucket(maxNum+1,0);
        // 统计数组中不同数值的个数
        for(int i=0; i<n; ++i){
            ++bucket[A[i]];
        }
        // 计算空缺的桶的索引值的差值
        int res = 0;
        int tmp = 0;
        for(int j=1; j<=maxNum; ++j){
            if(bucket[j] > 0){
                // 更新当前最大差值
                res = (res > tmp)? res:tmp;
                tmp = 0;
            }else{
                ++tmp;
            }
        }
        // 如果res!=0,需要加1
        return (res !=0)?(res+1) : res;
    }
    int getMax(vector<int> A, int n){
        int max=A[0];
        for(int i=1; i<n; ++i)
            max = (max > A[i])? max:A[i];
        return max;
    }
};
```

这是利用桶排序的思路，先根据数组最大值`maxNum`创建一个长度是`maxNum+1`的桶，然后根据数组元素的数值作为索引，找到其在桶中的位置，让对应位置的桶计数加1，之后通过空缺的桶的连续个数来得到数组相邻两数的最大差值。

------

### 字符串

#### 1. 词语变形

题目如下：

> 对于两个字符串A和B，如果A和B中出现的字符种类相同且每种字符出现的次数相同，则A和B互为变形词，请设计一个高效算法，检查两给定串是否互为变形词。
>
> 给定两个字符串**A**和**B**及他们的长度，请返回一个bool值，代表他们是否互为变形词。
>
> 测试样例：
>
> > "abc", 3, "bca", 3
>
> > 返回：true

解法如下：

```c++
class Transform {
public:
    bool chkTransform(string A, int lena, string B, int lenb) {
        // 分别建立两个数组作为哈希表
        char da[256] = {0}, db[256] = {0};
        // 分别统计两个数组的字符种类和出现个数
        for(int i=0; i<lena; ++i)
            ++da[A[i]];
        for(int j=0; j<lenb; ++j)
            ++db[B[j]];
        for(int k=0; k<256; ++k){
            if(da[k] != db[k])
                return false;
        }
        return true;
    }
};
```

这个方法主要是使用哈希表来分别统计两个数组的字符种类和出现次数，然后一一比较即可。

#### 2. 两串旋转

>如果对于一个字符串A，将A的前面任意一部分挪到后边去形成的字符串称为A的旋转词。比如A="12345",A的旋转词有"12345","23451","34512","45123"和"51234"。对于两个字符串A和B，请判断A和B是否互为旋转词。
>
>给定两个字符串**A**和**B**及他们的长度**lena**，**lenb**，请返回一个bool值，代表他们是否互为旋转词。
>
>测试样例：
>
> > cdab",4,"abcd",4
>
> > 返回：true

解法如下：

```c++
 bool chkRotation(string A, int lena, string B, int lenb) {
        // 先判断两个字符串是否长度相同
        if(lena != lenb)
            return false;
        if(A.size() <= 0 && B.size() > 0)
            return false;
        if(A.size() > 0 && B.size() <= 0)
            return false;
        // 拼接两个字符串A
        string str = A + A;
        int lens = lena + lena;
        int b_index = 0;
        for(int i=0; i < lens && b_index < lenb; ++i)
            // 遍历新字符串，寻找字符串B
            if(str[i] == B[b_index])
                ++b_index;
        return (b_index == lenb);
    }
```

上述解法是先判断两个字符串是否相等，相等的情况下，拼接两个字符串A得到一个新字符串，在这个新字符串中寻找是否存在字符串B。

另一个简洁的代码如下：

```c++
bool chkRotation(string A, int lena, string B, int lenb) {
        // write code here
        if(lena==lenb){
        //find函数的返回值是整数，假如字符串存在包含关系，其返回值必定不等于npos，但如果字符串不存在包含关系，
         //那么返回值就一定是npos
            string C=A+A;
            if(C.find(B)!= string::npos){
               return  true; 
            }  
        }
        return false;
    }
```



#### 3. 句子的逆序

> 对于一个字符串，请设计一个算法，只在字符串的单词间做逆序调整，也就是说，字符串由一些由空格分隔的部分组成，你需要将这些部分逆序。
>
> 给定一个原字符串**A**和他的长度，请返回逆序后的字符串。
>
> 测试样例：
>
> > "dog loves pig",13
>
> > 返回："pig loves dog"
>

解法如下：

```c++
string reverseSentence(string A, int n) {
        if(A.size() <= 0)
            return NULL;
        // 先翻转整个字符串
        reverse(A.begin(), A.end());
        int pBegin = 0, pEnd = 0;
        // 再逐个单词翻转
        while(pBegin < n){
            if(A[pBegin] == ' '){
                // 开头指针指向空格，两个指针同时增加
                ++pBegin;
                ++pEnd;
            }else if(A[pEnd] == ' ' || A[pEnd] == '\0'){
                // 尾指针指向空格或者结束符，都表示遇到一个单词
                reverse(A.begin()+pBegin, A.begin()+pEnd);
                pBegin = pEnd;
            }
            else{
                ++pEnd;
            }
        }
        return A;
    }
```

上述解法首先是旋转整个字符串，然后再逐个单词旋转。

#### 4. 字符串移位 

> 对于一个字符串，请设计一个算法，将字符串的长度为len的前缀平移到字符串的最后。
>
> 给定一个字符串**A**和它的长度，同时给定**len**，请返回平移后的字符串。
>
> 测试样例：
>
> > "ABCDE",5,3
>
> > 返回："DEABC"
>

解法如下：

```c++
string stringTranslation(string A, int n, int len) {
        if(A.size() <= 0)
            return "";
        // 先旋转前len个字符
        reverseString(A, 0, len-1);
        // 然后选择剩余字符串
        reverseString(A, len, n-1);
        // 最后选择整个字符串
        reverseString(A, 0, n-1);
        return A;
    }
    
    void reverseString(string& A, int start, int end){
        while(start < end){
            char tmp = A[start];
            A[start] = A[end];
            A[end] = tmp;
            ++start;
            --end;
        }
    }
```

首先选择需要平移的前`len`个字符，然后平移剩余字符串，最后再整个字符串进行翻转即可。

#### 5. 拼接最小字典序

> 对于一个给定的字符串数组，请找到一种拼接顺序，使所有小字符串拼接成的大字符串是所有可能的拼接中字典序最小的。
>
> 给定一个字符串数组**strs**，同时给定它的大小，请返回拼接成的串。
>
> 测试样例：
>
> > ["abc","de"],2
> >
> > "abcde"


解法如下：

```c++
string findSmallest(vector<string> strs, int n) {
        if(strs.size() <= 0)
            return "";
        // 通过组合进行排序
        sort(strs.begin(),strs.end(),compare);
        string result;
        for(int i=0;i<n;++i)
            result += strs[i];
        return result;
    }
    
    static bool compare(const string& a, const string& b){
        string str1 = a+b;
        string str2 = b+a;
        return (str1 < str2)? true:false;
    }
```

上述解法是定义一个比较函数，对两个字符串按不同顺序拼接后进行排序，根据排序后的结果来进行递增排序。

#### 6. 合法括号序列判断

> 对于一个字符串，请设计一个算法，判断其是否为一个合法的括号串。
>
> 给定一个字符串**A**和它的长度**n**，请返回一个bool值代表它是否为一个合法的括号串。
>
> 测试样例：
>
> > "(()())",6
>
> > 返回：true
>
>
> 测试样例：
>
> > "()a()()",7
>
> > 返回：false
>
> 测试样例：
>
> > "()(()()",7
> >
> > 返回：false
>

解法如下：

```c++
bool chkParenthesis(string A, int n) {
        // 记录左右括号数量的差值
        int num = 0;
        for(int i=0; i<n; ++i){
            if(A[i] == '(')
                ++num;
            else if(A[i] == ')')
                --num;
            else
                // 非法字符
                return false;
            if(num < 0)
                // 表示右括号多于左括号
                return false;
        }
        return (num == 0);
    }
```

使用一个整型变量记录左右括号数量的差值，根据差值判断是否合法。

#### 7. 空格替换

> 请编写一个方法，将字符串中的空格全部替换为“%20”。假定该字符串有足够的空间存放新增的字符，并且知道字符串的真实长度(小于等于1000)，同时保证字符串由大小写的英文字母组成。
>
> 给定一个string **iniString** 为原始的串，以及串的长度 int **len**, 返回替换后的string。
>
> 测试样例：
>
> > "Mr John Smith”,13
>
> > 返回："Mr%20John%20Smith"
>
> > ”Hello  World”,12
>
> > 返回：”Hello%20%20World”
>

解法如下：

```c++
class Replacement {
public:
    string replaceSpace(string iniString, int length) {
        if(iniString.size() <= 0)
            return "";
        int numBlanks=0;
        // 计算空格的数量
        for(int i=0; i<length;++i)
            if(iniString[i] == ' ')
                ++numBlanks;
        // 新长度
        int newLength = length + 2*numBlanks;
        string res(newLength,' ');
        int i = length-1, j = newLength-1;
        while(i >= 0){
            // 开始替换空格
            if(iniString[i] == ' '){
                res[j--] = '0';
                res[j--] = '2';
                res[j--] = '%';
            }else{
                res[j--] = iniString[i];
            }
            --i;
        }
        return res;
    }
};
```

需要先计算空格数量，然后新建一个新长度的字符串，并分别从两个字符串末尾开始往前遍历。

#### 8. 最长无重复字符子串

> 对于一个字符串,请设计一个高效算法，找到字符串的最长无重复字符的子串长度。
>
> 给定一个字符串**A**及它的长度**n**，请返回它的最长无重复字符子串长度。保证A中字符全部为小写英文字符，且长度小于等于500。
>
> 测试样例：
>
> > "aabcb",5
>
> > 返回：3
>

解法如下：

```c++
int longestSubstring(string A, int n) {
       //空间复杂度O（n），时间复杂度O（n）
       vector<int> map(26,-1);//保存当前字符出现的前一个位置
       vector<int> ans(n,0);//保存以i位置字符结尾的每最长无重复子串的长度
       int ret = 0;
 
       ans[0] = 1;
       map[A[0] - 'a'] = 0;
       for (int i = 1; i < n; i++) {
           // 计算当前位置的最长无重复子串是比较当前字符的上一个位置
           //和前一个字符位置得到的无重复子串长度的起始位置，取两者中最大值
           ans[i] = i - max(i - ans[i - 1], map[A[i] - 'a']+1) + 1;
           // 更新当前字符出现的最新位置
           map[A[i] - 'a'] = i;
           if (ret < ans[i]) 
               ret = ans[i];
       }
             
       return ret;
    }
```

上述解法使用了一个哈希表，用于记录当前字符出现的上个位置；再用一个数组记录以当前位置为字符结尾的最长无重复子串长度。每次循环的时候，最长无重复子串长度是根据当前字符上一个位置，以及前一个位置的最长无重复子串长度和当前位置差值，取这两个数值的最大值。

------

### 队列和栈

#### 1. 可查询最值的栈

> 定义栈的数据结构，请在该类型中实现一个能够得到栈最小元素的min函数

解法如下：

```c++
class Solution {
private:
    stack<int> data;
    stack<int> min_d;
public:
    void push(int value) {
        if(min_d.size() <= 0 || value < min_d.top()){
            // 当待插入数值小于min_d栈顶元素或者min_d是空，压入min_d中
            min_d.push(value);
        }else{
            min_d.push(min_d.top());
        }
        data.push(value);
    }
    void pop() {
        if(data.size() > 0 && min_d.size() > 0){
            data.pop();
            min_d.pop();
        }
    }
    int top() {
        return data.top();
    }
    int min() {
        return min_d.top();
    }
};
```

采用两个栈实现，一个栈保存插入的数据，一个栈保存当前最小值。

#### 2. 双栈队列

> 编写一个类,只能用两个栈结构实现队列,支持队列的基本操作(push，pop)。
>
> 给定一个操作序列**ope**及它的长度**n**，其中元素为正数代表push操作，为0代表pop操作，保证操作序列合法且一定含pop操作，请返回pop的结果序列。
>
> 测试样例：
>
> > [1,2,3,0,4,0],6
>
> > 返回：[1,2]
>

解法如下：

```c++
class TwoStack {
private:
    stack<int> s1;
    stack<int> s2;
public:
    vector<int> twoStack(vector<int> ope, int n) {
        if(ope.size() <= 0)
            return vector<int>();
        vector<int> res;
        for(int i=0; i<n; ++i){
            if(ope[i] == 0)
                res.push_back(pop());
            else
                push(ope[i]);
        }
        return res;
    }
    
    void push(int val){
        // s1专门用于保存插入的数据
        s1.push(val);
    }
    int pop(){
        if(s2.empty()){
            // s2是空的时候，将s1的元素都压入s2，并弹出s2的栈顶
            while(!s1.empty()){
                int tmp = s1.top();
                s1.pop();
                s2.push(tmp);
            }
        }
        int res = s2.top();
        s2.pop();
        return res;
    }
};
```

用两个栈实现队列，其中栈1专门用来保存`push`的数值，而栈2则是用于`pop`操作，它是将栈1中的元素都压入，这样栈2弹出的顺序就是所有元素压入的顺序，实现了队列的先进先出的特性。

#### 3. 栈的反转

> 实现一个栈的逆序，但是只能用递归函数和这个栈本身的pop操作来实现，而不能自己申请另外的数据结构。
>
> 给定一个整数数组**A**即为给定的栈，同时给定它的大小**n**，请返回逆序后的栈。
>
> 测试样例：
>
> > [4,3,2,1],4
>
> > 返回：[1,2,3,4]
>

解法如下：

```c++
class StackReverse {
public:
    vector<int> reverseStack(vector<int> A, int n) {
        int top = n-1;
        reverse(A, top);
        return A;
    }
    int pop(vector<int>& A, int& top){
        int val = A[top--];
        return val;
    }
    void push(vector<int>& A, int& top, int val){
        A[++top] = val;
    }
    // 移除栈顶元素，并返回它
    int removeBottom(vector<int>& A, int& top){
        int res = pop(A,top);
        if(top < 0){
            return res;
        }else{
            int bottom = removeBottom(A, top);
            // 压回非栈底元素
            push(A, top, res);
            return bottom;
        }
    }
    // 反转栈
    void reverse(vector<int>& A, int& top){
        if(top < 0){
            return;
        }else{
            // 得到栈底元素
            int res = removeBottom(A, top);
            reverse(A, top);
            // 将栈底元素放到最前
            push(A, top, res);
        }
    }
};
```

上述解法主要是`removeBottom`函数和`reverse`两个函数，前者是移除栈中的栈底元素，并返回它，而其他元素则按原来顺序存放在栈中，而`reverse`函数则是实现反转的操作。

#### 4. 双栈排序

> 请编写一个程序，按升序对栈进行排序（即最大元素位于栈顶），要求最多只能使用一个额外的栈存放临时数据，但不得将元素复制到别的数据结构中。
>
> 给定一个int[] **numbers**(C++中为vector<int>)，其中第一个元素为栈顶，请返回排序后的栈。请注意这是一个栈，意味着排序过程中你只能访问到第一个元素。
>
> 测试样例：
>
> > [1,2,3,4,5]
>
> > 返回：[5,4,3,2,1]
>

解法如下：

```c++
class TwoStacks {
public:
    vector<int> twoStacksSort(vector<int> numbers) {
        if(numbers.size() <= 0)
            return vector<int>();
        // 使用一个临时栈，从栈底到栈顶是降序，即最小值在栈顶
        stack<int> s;
        int i=0;
        while( i<numbers.size()){
            if(s.empty() || numbers[i] >= s.top()){
                // 临时栈为空或者大于栈顶元素，则压入
                s.push(numbers[i]);
            	++i;
        	}
     		else{
                // 将较小的当前元素放到前一个位置
                numbers[i-1] = numbers[i];
                // 将较大的栈顶元素放到当前位置，然后从i-1位置开始再次循环
                numbers[i] = s.top();
                s.pop();
                --i;
            }
        }
        // 将排序好的临时栈依次放回原栈中
        for(int i=0; i<numbers.size(); ++i){
            numbers[i] = s.top();
            s.pop();
        }
        return numbers;
    }
};
```

上述算法利用一个辅助栈来实现对栈元素的排序。

#### 5. 滑动窗口

> 有一个整型数组 arr 和一个大小为 w 的窗口从数组的最左边滑到最右边,窗口每次向右边滑一个位置。 返回一个长度为n-w+1的数组res，res[i]表示每一种窗口状态下的最大值。 以数组为[4,3,5,4,3,3,6,7]，w=3为例。因为第一个窗口[4,3,5]的最大值为5，第二个窗口[3,5,4]的最大值为5，第三个窗口[5,4,3]的最大值为5。第四个窗口[4,3,3]的最大值为4。第五个窗口[3,3,6]的最大值为6。第六个窗口[3,6,7]的最大值为7。所以最终返回[5,5,5,4,6,7]。
>
> 给定整形数组**arr**及它的大小**n**，同时给定**w**，请返回res数组。保证**w**小于等于**n**，同时保证数组大小小于等于500。
>
> 测试样例：
>
> > [4,3,5,4,3,3,6,7],8,3
>
> > 返回：[5,5,5,4,6,7]
>

解法如下：

```c++
vector<int> slide(vector<int> arr, int n, int w) {
        // 定义一个队列保存数组下标
        deque<int> ins;
        vector<int> res;
        if(n >= w && w >= 1){
            // 初始滑动窗口
            for(unsigned int i = 0; i<w; ++i){
                while(!ins.empty() && arr[i] >= arr[ins.back()])
                    // 队列末尾元素小于当前元素，则弹出
                    ins.pop_back();
                ins.push_back(i);
            }
            // 继续滑动窗口
            for(unsigned int i = w; i<n; ++i){
                // 保存队列头部元素
                res.push_back(arr[ins.front()]);
                while(!ins.empty() && arr[i] >= arr[ins.back()])
                    // 队列末尾元素小于当前元素，则弹出
                    ins.pop_back();
                while(!ins.empty() && ins.front() <=(int)(i-w))
                    // 队列头部超出滑动窗口范围
                    ins.pop_front();
                ins.push_back(i);
            }
            res.push_back(arr[ins.front()]);
        }
        return res;
    }
```

利用一个队列保存滑动窗口中元素的下标，这个元素是当前窗口中的最大值以及可能成为最大值的结果。因此，队列首部必然是最大值，而末尾元素如果小于新进入的元素，则会被弹出队列中。滑动过程还要注意队列头部的下标是否超过滑动窗口范围，需要及时弹出。同时考虑最后一个窗口的最大值要记得保存。

#### 6. 数组变树

> 对于一个没有重复元素的整数数组，请用其中元素构造一棵MaxTree，MaxTree定义为一棵二叉树，其中的节点与数组元素一一对应，同时对于MaxTree的每棵子树，它的根的元素值为子树的最大值。现有一建树方法，对于数组中的每个元素，其在树中的父亲为数组中它左边比它大的第一个数和右边比它大的第一个数中更小的一个。若两边都不存在比它大的数，那么它就是树根。请设计O(n)的算法实现这个方法。
>
> 给定一个无重复元素的数组**A**和它的大小**n**，请返回一个数组，其中每个元素为原数组中对应位置元素在树中的父亲节点的编号，若为根则值为-1。
>
> 测试样例：
>
> > [3,1,4,2],4
>
> > 返回：[2,0,-1,2]
>

解法如下：

```c++
class MaxTree {
public:
    vector<int> buildMaxTree(vector<int> A, int n) {
        // 定义两个数组分别存放左边第一个大和右边第一个大的数
        vector<int> left(n);
        vector<int> right(n);
        vector<int> res;
        // 两个栈，用来辅助寻找左右第一个比当前元素大的数值
        stack<int> s1;
        stack<int> s2;
        for(int i=0; i<n; ++i){
            // 寻找左边第一个比A[i]大的元素
            while(!s1.empty() && A[i] > A[s1.top()]){
                // 当前元素大于栈顶元素，则弹出栈顶
                s1.pop();
            }
            if(!s1.empty()){
                // 栈顶元素就是左边第一个大的元素
                left[i] = s1.top();
            }else{
                // 否则，左边没有找到大于自己的元素
                left[i] = -1;
            }
            s1.push(i);
        }
        // 接下来寻找右边第一个比自己大的数
        for(int i=n-1; i>=0; --i){
            while(!s2.empty() && A[i] > A[s2.top()]){
                // 当前元素大于栈顶元素，则弹出栈顶
                s2.pop();
            }
            if(!s2.empty()){
                // 栈顶元素就是右边第一个大的元素
                right[i] = s2.top();
            }else{
                // 否则，右边没有找到大于自己的元素
                right[i] = -1;
            }
            s2.push(i);
        }
        // 进行比较，确定每个数组位置上父结点的位置
        for(int i=0; i<n; ++i){
            // 对比左右两个数，哪个更小
            if(left[i] == -1 && right[i] == -1)
                res.push_back(-1);
            else if(left[i] == -1)
                res.push_back(right[i]);
            else if(right[i] == -1)
                res.push_back(left[i]);
            else{
                int ind = (A[left[i]] <= A[right[i]])? left[i]:right[i];
            	res.push_back(ind);
            }
        }
        return res;
    }
};
```

这道题目需要找到当前元素左右两边第一个大于自己的元素，分别用两个栈进行辅助，当前元素如果小于栈顶元素，则压入栈中，否则就一直弹出栈顶元素，直到找到大于当前元素的栈顶元素为止。最后是比较左右两边的元素，取最小值的下标。

------

### 链表

#### 1. 环形链表插值

> 有一个整数val，如何在节点值有序的环形链表中插入一个节点值为val的节点，并且保证这个环形单链表依然有序。
>
> 给定链表的信息，及元素的值**A**及对应的**nxt**指向的元素编号同时给定**val**，请构造出这个环形链表，并插入该值。
>
> 测试样例：
>
> > [1,3,4,5,7],[1,2,3,4,0],2
>
> >返回：{1,2,3,4,5,7}
>

解法如下：

```c++
/*
struct ListNode {
    int val;
    struct ListNode *next;
    ListNode(int x) : val(x), next(NULL) {}
};*/
class InsertValue {
public:
    ListNode* insert(vector<int> A, vector<int> nxt, int val) {
        // write code here
        if(A.size() == 0){
            ListNode* res = new ListNode(val);
            res->next = res;
            return res;
        }
        if(A.size() == 1){
            ListNode* tmp1 = new ListNode(val);
            ListNode* tmp2 = new ListNode(A[0]);
            if(A[0] > val){
                tmp1->next = tmp2;
                tmp2->next = tmp1;
                return tmp1;
            }
            else{
                tmp2->next = tmp1;
                tmp1->next = tmp2;
                return tmp2;
            }
        }
        ListNode* head = new ListNode(A[0]);
        ListNode* build = head;
        int i = 1;
        int len = A.size();
        //构建链表
        while(i < len){
            ListNode* tmp = new ListNode(A[i++]);
            build->next = tmp;
            build = build->next;
        }
        build->next = NULL;
         
        ListNode* pre = head;
        ListNode* cur = head->next;
        while(1){
            if(val >= pre->val && val <= cur->val){
                ListNode* tmp = new ListNode(val);
                pre->next = tmp;
                tmp->next = cur;
                return head;
            }
            pre = pre->next;
            cur = cur->next;
            if(cur == NULL)
                break;
        }
        if(val > pre->val){
            ListNode* tmp = new ListNode(val);
            pre->next = tmp;
            tmp->next = NULL;
        }
        if(val <= head->val){
            ListNode* tmp = new ListNode(val);
            //pre->next = NULL;
            tmp->next = head;
            return tmp;
        }
        return head;
    }
};
```

循环链表，首先要判断链表是否为空，如果是空，根据插入值构建的结点就直接指向自己，并返回；如果不空，就构建链表，并找到合适的位置插入，这里可能会出现没有找到位置，说明插入值比链表的数值要小或者大，如果是前者，注意返回的是插入值构建的结点，因为它是链表的头节点。

#### 2. 删除链表的单结点

> 实现一个算法，删除单向链表中间的某个结点，假定你只能访问该结点。
>
> 给定带删除的节点，请执行删除操作，若该节点为尾节点，返回false，否则返回true

解法如下：

```c++
/*
struct ListNode {
    int val;
    struct ListNode *next;
    ListNode(int x) : val(x), next(NULL) {}
};*/
class Remove {
public:
    bool removeNode(ListNode* pNode) {
        if(pNode->next == NULL){
            // 尾结点返回false
            return false;
        }else{
            // 复制下个结点，并删除下一个结点
            ListNode* deleteNode = pNode->next;
            pNode->val = deleteNode->val;
            pNode->next = deleteNode->next;
            delete deleteNode;
            deleteNode = NULL;
        }
        return true;
    }
};
```

$O(1)$时间删除给点结点，其实就是复制下个结点的内容到当前结点，然后删除下一个结点，这要求当前结点不是尾结点。

#### 3. 链表的分化

> 对于一个链表，我们需要用一个特定阈值完成对它的分化，使得小于等于这个值的结点移到前面，大于该值的结点在后面，同时保证两类结点内部的位置关系不变。
>
> 给定一个链表的头结点**head**，同时给定阈值**val**，请返回一个链表，使小于等于它的结点在前，大于等于它的在后，保证结点值不重复。
>
> 测试样例：
>
> > {1,4,2,5},3
>
> >{1,2,4,5}
>

解法如下：

```c++
/*
struct ListNode {
    int val;
    struct ListNode *next;
    ListNode(int x) : val(x), next(NULL) {}
};*/
class Divide {
public:
    ListNode* listDivide(ListNode* head, int val) {
        if(head == NULL || head->next == NULL)
            return NULL;
        ListNode *minHead = NULL, *minTail = NULL;
        ListNode *maxHead = NULL, *maxTail = NULL;
        ListNode* pNode = head;
        while(pNode != NULL){
            if(pNode->val <= val){
                if(minHead == NULL){
                    minHead = pNode;
                    minTail = pNode;
                }else{
                    minTail->next = pNode;
                    minTail = pNode;
                }
            }
            if(pNode->val > val){
                if(maxHead == NULL){
                    maxHead = pNode;
                    maxTail = pNode;
                }else{
                    maxTail->next = pNode;
                    maxTail = pNode;
                }
            }
            pNode = pNode->next;
        }
        if(!minHead)
            // 只有大于val的数
            return maxHead;
        if(!maxHead)
            return minHead;
        maxTail->next = NULL;
        minTail->next = maxHead;
        return minHead;
    }
};
```

这是将链表分成两部分，一部分是小于等于阈值的链表，一部分是大于阈值的链表，然后再合并。

#### 4. 打印两个链表的公共值

> 现有两个升序链表，且链表中均无重复元素。请设计一个高效的算法，打印两个链表的公共值部分。
>
> 给定两个链表的头指针**headA**和**headB**，请返回一个vector，元素为两个链表的公共部分。请保证返回数组的升序。两个链表的元素个数均小于等于500。保证一定有公共值
>
> 测试样例：
>
> > {1,2,3,4,5,6,7},{2,4,6,8,10}
>
> > 返回：[2.4.6]
>

解法如下：

```c++
/*
struct ListNode {
    int val;
    struct ListNode *next;
    ListNode(int x) : val(x), next(NULL) {}
};*/
class Common {
public:
    vector<int> findCommonParts(ListNode* headA, ListNode* headB) {
        if(headA == NULL || headB == NULL)
            return vector<int>();
        vector<int> res;
        while(headA != NULL && headB != NULL){
            if(headA->val < headB->val){
                headA = headA->next;
            }else if(headA->val > headB->val){
                headB = headB->next;
            }else{
                res.push_back(headA->val);
                headA = headA->next;
                headB = headB->next;
            }
        }
        return res;
    }
};
```

主要就是相互比较，如果相等就保存下来，否则就让值更小的链表往后移动一步。

#### 5. 链表的k逆序

> 有一个单链表，请设计一个算法，使得每K个节点之间逆序，如果最后不够K个节点一组，则不调整最后几个节点。例如链表1->2->3->4->5->6->7->8->null，K=3这个例子。调整后为，3->2->1->6->5->4->7->8->null。因为K==3，所以每三个节点之间逆序，但其中的7，8不调整，因为只有两个节点不够一组。
>
> 给定一个单链表的头指针**head**,同时给定K值，返回逆序后的链表的头指针。

解法如下：

```c++
/*
struct ListNode {
    int val;
    struct ListNode *next;
    ListNode(int x) : val(x), next(NULL) {}
};*/
class KInverse {
public:
    ListNode* inverse(ListNode* head, int k) {
        stack<int> vals;
        ListNode* pNode = head;
        ListNode* newHead = head;
        if(head == NULL || k < 2)
            return head;
        int i=0;
        while(pNode != NULL){
            ++i;
            // 使用栈保存结点数值
            vals.push(pNode->val);
            if(i==k){
                while(!vals.empty()){
                    // 依次弹出栈中数值，相当于做了逆序
                    newHead->val = vals.top();
                    vals.pop();
                    newHead = newHead->next;
                }
                i = 0;
            }
            pNode = pNode->next;
        }
        return head;
    }
};
```

这是使用栈来保存结点数值，每次遍历k个数值后，就弹出栈中数值，此时就相当于做了逆序操作。

最优解如下：

```c++
class KInverse {
public:
    ListNode* inverse(ListNode* head, int k) {
        ListNode* prehead=new ListNode(0);//申请新的节点，避免边界问题
        prehead->next=head;
        ListNode* begin=head;
        ListNode* lastkend=prehead;//每k个元素为一组，中间需要链接，当前链接尾
        ListNode* khead;//每组的头结点
        ListNode* kend;//每组的尾节点
        ListNode* nextbegin;//下一组的头结点
        if(!head)
            return NULL;
        if(k<=1)
            return head;        
        while(1){ 
        int i=1;
        while(i%k!=0&&head){
        head=head->next;
        ++i;
        }       //head为尾节点，如果尾节点为空，则不用翻转
        if(i%k==0&&head)
        {
        nextbegin=head->next;//下一组的头节点必须保存下，要不然翻转之后head->next不再是下一组头
        inverse_k(begin,k,khead,kend);//组内翻转
        lastkend->next=khead;//将翻转好的组加入链中
        lastkend=kend;//新的链末尾
        begin=nextbegin;//下一组开始
        head=nextbegin;//新的头
        }
        else
        {
        lastkend->next=nextbegin; //如果头为空，不翻转直接链接
        return prehead->next;            
        }        
        }
        return NULL;
    }
    void inverse_k(ListNode* head,int k,ListNode* &khead,ListNode* &kend)
        {
        ListNode* prehead=new ListNode(0);
        ListNode* pre=prehead;
        prehead->next=head;
        ListNode* next=head->next; 
 
        while(k>2)
            {
            head->next=pre;
            pre=head;
            head=next;
            next=next->next;
            --k;
        }  
        //翻转一个链需要借助三个临时变量才可以完成
        next->next=head;
        head->next=pre;
        khead=next;
        kend=prehead->next;
        kend->next=NULL;
        delete prehead;
        prehead=NULL;
    }
};
```

这是不需要辅助空间的做法。

#### 6. 链表指定值删除 

> 现在有一个单链表。链表中每个节点保存一个整数，再给定一个值val，把所有等于val的节点删掉。
>
> 给定一个单链表的头结点**head**，同时给定一个值**val**，请返回清除后的链表的头结点，保证链表中有不等于该值的其它值。请保证其他元素的相对顺序。
>
> 测试样例：
>
> > {1,2,3,4,3,2,1},2
>
> > {1,3,4,3,1}
>

解法如下：

```c++
/*
struct ListNode {
    int val;
    struct ListNode *next;
    ListNode(int x) : val(x), next(NULL) {}
};*/
class ClearValue {
public:
    ListNode* clear(ListNode* head, int val) {
        if(head == NULL)
            return NULL;
        while(head != NULL && head->val == val)
            // 删除头结点是指定值的情况
            head = head->next;
        ListNode* pre = head;
        ListNode* node = head->next;
        while(node != NULL){
            if(node->val == val){
                pre->next = node->next;
                node = pre->next;
            }else{
                pre = node;
                node = node->next;
            }
        }
        return head;
    }
    
};
```

这里要注意头结点是否等于指定值的情况。

#### 7. 链表的回文结构

> 请编写一个函数，检查链表是否为回文。
>
> 给定一个链表ListNode* **pHead**，请返回一个bool，代表链表是否为回文。
>
> 测试样例：
>
> > {1,2,3,2,1}
>
> > 返回：true
>
> > {1,2,3,2,3}
>
> > 返回：false
>

解法如下：

```c++
/*
struct ListNode {
    int val;
    struct ListNode *next;
    ListNode(int x) : val(x), next(NULL) {}
};*/
class Palindrome {
public:
    bool isPalindrome(ListNode* pHead) {
        if(pHead == NULL || pHead->next == NULL)
            return false;
       	ListNode *p = NULL;
        ListNode *q = pHead;
        while(pHead){
            if(!p) p = new ListNode(pHead->val);
            else{
                ListNode *tmp = new ListNode(pHead->val);
                tmp->next = p;
                p = tmp;
            }
            pHead = pHead->next;
        }
         while(q){
            if(q->val != p->val) return false;
            q = q->next;
            p = p->next;
        }
        return true;
    }
};
```

上述解法是新建立一个链表，是原链表的反转顺序，然后依次比较。另一种借助栈的解法如下：

```c++
bool isPalindrome(ListNode* pHead) {
        // write code here
        stack<int> s;
        ListNode* p = pHead;
        while (p != NULL){
            s.push(p->val);
            p = p->next;
        }
        p = pHead;
        while (p != NULL){
            if (s.top() != p->val)    return false;
            s.pop();
            p = p->next;
        }
        return true;
    }
```

#### 8. 复杂链表的复制

> 输入一个复杂链表（每个节点中有节点值，以及两个指针，一个指向下一个节点，另一个特殊指针指向任意一个节点）。

解法如下：

```c++
/*
struct RandomListNode {
    int label;
    struct RandomListNode *next, *random;
    RandomListNode(int x) :
            label(x), next(NULL), random(NULL) {
    }
};
*/
class Solution {
public:
    RandomListNode* Clone(RandomListNode* pHead)
    {
        cloneFirst(pHead);
        cloneRandom(pHead);
        return splitList(pHead);
    }
    // 先复制链表的数值和next指针，并插入到每个结点后面
    void cloneFirst(RandomListNode* head){
        RandomListNode* node = head;
        while(node != NULL){
            RandomListNode* clone = new RandomListNode(node->label);
            clone->next = node->next;
            // 将复制的结点先插入到原结点后面
            node->next = clone;
            // 遍历到下个结点
            node = clone->next;
        }
    }
    // 复制结点的随机结点
    void cloneRandom(RandomListNode* head){
        RandomListNode* node = head;
        while(node != NULL){
            RandomListNode* clone = node->next;
            if(node->random != NULL)
                clone->random = node->random;
            node = clone->next;
        }
    }
    // 拆分链表，变成原始链表和复制得到的链表
    RandomListNode* splitList(RandomListNode* head){
        RandomListNode* node = head;
        // 复制链表的头结点和遍历结点
        RandomListNode* cloneHead = NULL;
        RandomListNode* cloneNode = NULL;
        if(node != NULL){
            cloneHead = cloneNode = node->next;
            // 原结点指向原始的结点，而非其复制结点
            node->next = cloneNode->next;
            node = node->next;
        }
        while(node != NULL){
            cloneNode->next = node->next;
            cloneNode = cloneNode->next;
            node->next = cloneNode->next;
            node = node->next;
        }
        return cloneHead;
    }
};
```

先复制每个结点，并插入到原结点后面，然后再复制结点的`random`结点，这就完成复制结点的复制，之后就是将原结点和复制结点分开，变成两个链表。

#### 9. 链表判环

> 

解法如下：



------
### 位运算

#### 1. 交换练习

> 给定一个数组**num**，其中包含两个值，请不用任何额外变量交换这两个值，并将交换后的数组返回。
>
> 测试样例：
>
>
> > [1,2]
>
> > 返回：[2,1]

解法如下：

```c++
vector<int> getSwap(vector<int> num) {
        // 使用异或交换两个数
        num[0] ^= num[1];
        num[1] ^= num[0];
        num[0] ^= num[1];
        return num;
}
```

使用异或方法进行交换两个数。

#### 2. 比较练习

> 对于两个32位整数a和b，请设计一个算法返回a和b中较大的。但是不能用任何比较判断。若两数相同，返回任意一个。
>
> 给定两个整数**a**和**b**，请返回较大的数。
>
> 测试样例：
>
> > 1,2
>
> > 返回：2

解法如下：

```c++
int getMax(int a, int b) {
        // 获取两个数的差值
        int c = a - b;
        // 查看符号位，如果是负数，结果是1，正数是0
        int flag = (c>>31) & 1;
        // flag是负数，返回b，是正数，则返回a
        return b*flag + a*(flag ^ 1);
}
```

解法主要是判断两个整数差值的符号位。

#### 3. 寻找奇数出现

> 有一个整型数组A，其中只有一个数出现了奇数次，其他的数都出现了偶数次，请打印这个数。要求时间复杂度为O(N)，额外空间复杂度为O(1)。
>
> 给定整形数组**A**及它的大小**n**，请返回题目所求数字。
>
> 测试样例：
>
> > [1,2,3,2,1],5
>
> > 返回：3

解法如下：

```c++
int findOdd(vector<int> A, int n) {
        int res = A[0];
        // 对每个数都进行异或，最终结果就是只出现奇数次的数字
        for(int i=1; i<n; ++i)
            res ^= A[i];
        return res;
    }
```

使用异或运算，偶数次的元素会变成0，剩下的结果就是奇数次的数。

#### 4. 奇数出现2

> 给定一个整型数组arr，其中有两个数出现了奇数次，其他的数都出现了偶数次，找到这两个数。要求时间复杂度为O(N)，额外空间复杂度为O(1)。
>
> 给定一个整形数组**arr**及它的大小**n**，请返回一个数组，其中两个元素为两个出现了奇数次的元素,请将他们按从小到大排列。
>
> 测试样例：
>
> > [1,2,4,4,2,1,3,5],8
>
> > 返回：[3,5]

解法如下：

```c++
class OddAppearance {
public:
    vector<int> findOdds(vector<int> arr, int n) {
        int res = 0;
        for(int i=0; i<n; ++i)
            res ^= arr[i];
        unsigned int indexOf1 = findBitsOf1(res);
        vector<int> r(2,0);
        for(int j=0; j<n; ++j){
            // 根据indexOf1位上是否为1分成两组
            if(isBit1(arr[j],indexOf1))
                r[0] ^= arr[j];
            else
                r[1] ^= arr[j];
        }
        sort(r.begin(), r.end());
        return r;
    }
    
    // 寻找出现1的位数
    unsigned int findBitsOf1(int n){
        int count = 0;
        while((n & 1) == 0 && count < sizeof(int) * 8){
            ++count;
            n = n >> 1;
        }
        return count;
    }
    // 判断给定的位数上是否为1
    bool isBit1(int n, unsigned int index){
        n = n >> index;
        return (n & 1);
    }
};
```

这个方法也是使用了异或，对数组的所有元素都进行异或后，得到的结果由于有两个数是奇数次，所以不为0，因此先找出第一个为1的位，根据这个将数组分成两部分，分别进行异或就可以得到结果。

------

### 排列组合

排列公式为$A_n^m = \frac{n!}{(n-m)!}$;

组合公式是$C_n^m = \frac{A_n^m}{m!} = \frac{n!}{m!(n-m)!}$。



#### 1.  方格移动

> 在XxY的方格中，以左上角格子为起点，右下角格子为终点，每次只能向下走或者向右走，请问一共有多少种不同的走法
>
> 给定两个正整数int **x**,int **y**，请返回走法数目。保证x＋y小于等于12。
>
> 测试样例：
>
> > 2,2
>
> > 返回：2
>

解法如下：

```c++
class Robot {
public:
    int countWays(int x, int y) {
        if(x == 0 && y == 0)
            return 1;
        else if(x == 0)
            return y-1;
        else if(y == 0)
            return x-1;
        // 向下走的步数
        int cx = x-1;
        // 向右走的步数
        int cy = y-1;
		// 分别计算总的步数，然后进行组合，求C(cx+cy,cx) 或者 C(cx+cy,cy)
        return factorial(cx+cy) / (factorial(cx) * factorial(cy));
    }
    
    int factorial(int n){
        // 计算阶乘
        int res = 1;
        while(n > 0)
            res *= (n--);
        return res;
    }
};
```

上述解法首先求出总共需要走多少步数，也就是往下走的步数和往右走的步数，然后通过组合方法$C_{sum}^x = C_{sum}^y$,其中$sum = x+y$，也就是总的步数。

#### 2. 站队问题

> n个人站队，他们的编号依次从1到n，要求编号为a的人必须在编号为b的人的左边，但不要求一定相邻，请问共有多少种排法？第二问如果要求a必须在b的左边，并且一定要相邻，请问一共有多少种排法？
>
> 给定人数**n**及两个人的编号**a**和**b**，请返回一个两个元素的数组，其中两个元素依次为两个问题的答案。保证人数小于等于10。
>
> 测试样例：
>
> > 7,1,2
>
> >返回：[2520,720]
>

解法如下：

```c++
class StandInLine {
public:
    vector<int> getWays(int n, int a, int b) {
        if(n <= 0)
            return vector<int>();
        vector<int> res;
        // n个人的排列有n！种
        int total = factorial(n);
        // 不一定相邻的解法是n!/2
        res.push_back(total/2);
        // 一定相邻的解法是将这两个人当做一个人看，解法是(n-1)!
        int t2 = factorial(n-1);
        res.push_back(t2);
        return res;
    }
    int factorial(int n){
        // 计算阶乘
        int res = 1;
        while(n > 0)
            res *= (n--);
        return res;
    }
};
```

n个人的排列有`n!`种，而其中两个人，如a和b，他们的站队分别有两种形式，a在b左边或者a在b右边，现在第一种是要求a在b左边，所以是有`n!/2`种，而如果要求相邻，则可以将其看成是一个人，求n-1个人的排列方式，有`(n-1)!`种方法。

#### 3. 孤傲的A

> A(A也是他的编号)是一个孤傲的人，在一个n个人(其中编号依次为1到n)的队列中，他于其中的标号为b和标号c的人都有矛盾，所以他不会和他们站在相邻的位置。现在问你满足A的要求的对列有多少种？
>
> 给定人数**n**和三个人的标号**A**,**b**和**c**，请返回所求答案，保证人数小于等于11且大于等于3。
>
> 测试样例：
>
> > 6,1,2,3
>
> >288
>

解法如下：

```c++
class LonelyA {
public:
    int getWays(int n, int A, int b, int c) {
        if(n <= 3)
            return 0;
        // 总排列数
        int sum = factorial(n);
        // a和b相邻-->ab/ba 
        int ab = factorial(n-1)*2;
        // a和c相邻
        int ac = factorial(n-1)*2;
        // 上述两种情况中重复的情况是三者相邻
        int abc = factorial(n-2)*2;
        return sum - (ab+ac-abc);
    }
    int factorial(int n){
        // 计算阶乘
        int res = 1;
        while(n > 0)
            res *= (n--);
        return res;
    }
};
```
上述解法是分别求出a与b，a与c相邻的情况，然后用总数减去它们，这里注意a与b，c相邻都分别有两种排列，如ab或者ba，然后看做一个人，再来求排列可能，接着还需要减去三者相邻的情况。

#### 4. 分糖果

> n颗相同的糖果，分给m个人，每人至少一颗，问有多少种分法。
>
> 给定**n**和**m**，请返回方案数，保证n小于等于12，且m小于等于n。
>
> 测试样例：
>
> > 10,3
>
> > 返回：36
>

解法如下：

```c++
class Distribution {
public:
    int getWays(int n, int m) {
        if(n <= m && m <= 0)
            return 0;
        // 相当于n-1个空挡中放入m-1个隔板
        return factorial(n-1)/(factorial(m-1)*factorial(n-m));
    }
    int factorial(int n){
        int res = 1;
        while(n>0)
            res *= n--;
        return res;
    }
};
```

这个分糖果，n个人，有n-1个空挡，分给m个人，相当于用m-1个隔板隔开n个人，所以有$C_{n-1}^{m-1}$。

#### 5. 括号序列

> 假设有n对左右括号，请求出合法的排列有多少个？合法是指每一个括号都可以找到与之配对的括号，比如n=1时，()是合法的，但是)(为不合法。
>
> 给定一个整数**n**，请返回所求的合法排列数。保证结果在int范围内。
>
> 测试样例：
>
> > 1
>
> > 返回：1
>

解法如下：

```c++
int countLegalWays(int n) {
        if(n <= 0)
            return 0;
        // 总的排列C(2n,n)
        // 非法组合的可能有C(2n,n+1)
        // 结果是卡特兰数公式，即C(2n,n)/(n+1)
        int a=1;
        int b=1;
        for(int i=1;i<=n;i++)
        {
            a*=n+i;
            b*=i;
        }
        return a/b/(n+1);
    }
```

卡特兰数公式为$\frac{C_{2n}^n}{n+1}$。

#### 6. 进出栈

> n个数进出栈的顺序有多少种？假设栈的容量无限大。
>
> 给定一个整数**n**，请返回所求的进出栈顺序个数。保证结果在int范围内。
>
> 测试样例：
>
> > 1
>
> >返回：1
>

解法和上一题一样，也是使用卡特兰数公式解决。

#### 7. 排队买票

> 2n个人排队买票，n个人拿5块钱，n个人拿10块钱，票价是5块钱1张，每个人买一张票，售票员手里没有零钱，问有多少种排队方法让售票员可以顺利卖票。
>
> 给定一个整数**n**，请返回所求的排队方案个数。保证结果在int范围内。
>
> 测试样例：
>
> > 1
>
> > 返回：1
>

解法同样如括号序列一样，使用卡特兰数公式解决。

#### 8. 二叉树统计

> 求n个无差别的节点构成的二叉树有多少种不同的结构？
>
> 给定一个整数**n**，请返回不同结构的二叉树的个数。保证结果在int范围内。
>
> 测试样例：
>
> > 1
>
> > 返回：1
>

解法其实也是卡特兰数公式。该题目解法是通过枚举可以找到规律，即有

> $$
> f(0) = 1, f(1) = 1, f(2) = 2, f(3) = 5 \\
>  f(n) = f(0) * f(n-1) + f(1) * f(n-2) + f(2) * f(n-3) + ... + f(n-1) * f(0) \\
>        = \frac{1}{n+1} C_{2n}^n
> $$
>

#### 9. 高矮排列

> 12个高矮不同的人，排成两排，每排必须是从矮到高排列，而且第二排比对应的第一排的人高，问排列方式有多少种？
>
> 给定一个偶数**n**，请返回所求的排列方式个数。保证结果在int范围内。
>
> 测试样例：
>
> > 1
>
> > 返回：1

这道题目也是一个使用卡特兰数公式的解法。如下所示

```c++
class HighAndShort {
public:
    int countWays(int n) {
        if(n<=0)
            return 0;
        int a=1;
        int b=1;
        for(int i=1;i<=n/2;++i){
            a *= n/2+i;
            b *= i;
        }
        return a/b/(n/2+1);
    }
};
```

这里需要注意要使用`n/2`，是n个人分两排。

#### 10. 错装信封

> 有n个信封，包含n封信，现在把信拿出来，再装回去，要求每封信不能装回它原来的信封，问有多少种装法?
>
> 给定一个整数**n**，请返回装发个数，为了防止溢出，请返回结果Mod 1000000007的值。保证n的大小小于等于300。
>
> 测试样例：
>
> >2
>
> >返回：1
>

解法如下：

```c++
class CombineByMistake {
public:
    int countWays(int n) {
        if(n <= 1)
            return 0;
        if(n == 2)
            return 1;
        const int mod = 1000000007;
        // 避免溢出，定义long long类型
        vector<long long> res(n+1,0);
        res[2] = 1;
        for(int i=3; i<=n; ++i){
            res[i] = ((i-1)*(res[i-1]+res[i-2]))%mod;
        }
        return res[n];
    }
};
```

假设第n封信装到第i个信封,n是大于2，且不等于i，则有两种可能：

1. 第i封信装到第n个信封中，则后续是f(n-2)，此时是解决了两封信，剩下n-2封信处理；
2. 第i封信没有装到第n个信封中，则后续是f(n-1)。

而i其实有n-1种可能，所以有$f(n) = (n-1)(f(n-2)+f(n-1))$。

